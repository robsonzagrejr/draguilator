Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> make_scope statement close_scope
Rule 2     program -> make_scope funclist close_scope
Rule 3     program -> make_scope empty close_scope
Rule 4     funclist -> funcdef _funclist
Rule 5     _funclist -> funclist
Rule 6     _funclist -> empty
Rule 7     funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope
Rule 8     paramlist -> INT IDENT _paramlist
Rule 9     paramlist -> FLOAT IDENT _paramlist
Rule 10    paramlist -> STRING IDENT _paramlist
Rule 11    paramlist -> empty
Rule 12    _paramlist -> COMMA paramlist
Rule 13    _paramlist -> empty
Rule 14    statement -> vardecl SEMICOLON
Rule 15    statement -> atribstat SEMICOLON
Rule 16    statement -> printstat SEMICOLON
Rule 17    statement -> readstat SEMICOLON
Rule 18    statement -> returnstat SEMICOLON
Rule 19    statement -> ifstat
Rule 20    statement -> forstat
Rule 21    statement -> LBRACES statelist RBRACES
Rule 22    statement -> check_loop_scope BREAK SEMICOLON
Rule 23    statement -> SEMICOLON
Rule 24    vardecl -> INT IDENT vardecl_line
Rule 25    vardecl -> FLOAT IDENT vardecl_line
Rule 26    vardecl -> STRING IDENT vardecl_line
Rule 27    vardecl_line -> LBRACKET INT_CONSTANT RBRACKET vardecl_line
Rule 28    vardecl_line -> empty
Rule 29    atribstat -> lvalue ASSIGN _atribstat
Rule 30    _atribstat -> PLUS _atribstat_help
Rule 31    _atribstat -> MINUS _atribstat_help
Rule 32    _atribstat -> __atribstat
Rule 33    _atribstat -> IDENT ___atribstat
Rule 34    _atribstat -> allocexpression
Rule 35    _atribstat_help -> IDENT lvalue_line term_line numexpression_line _expression
Rule 36    _atribstat_help -> __atribstat
Rule 37    __atribstat -> _node_int_constant term_line numexpression_line _expression
Rule 38    __atribstat -> _node_float_constant term_line numexpression_line _expression
Rule 39    __atribstat -> _node_str_constant term_line numexpression_line _expression
Rule 40    __atribstat -> _node_null_constant term_line numexpression_line _expression
Rule 41    __atribstat -> LPAREN numexpression RPAREN term_line numexpression_line _expression
Rule 42    ___atribstat -> lvalue_line term_line numexpression_line _expression
Rule 43    ___atribstat -> LPAREN paramlistcall RPAREN
Rule 44    paramlistcall -> IDENT _paramlistcall
Rule 45    paramlistcall -> empty
Rule 46    _paramlistcall -> COMMA paramlistcall
Rule 47    _paramlistcall -> empty
Rule 48    printstat -> PRINT expression
Rule 49    readstat -> READ lvalue
Rule 50    returnstat -> RETURN
Rule 51    ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
Rule 52    _ifstat -> make_scope ELSE statement close_scope
Rule 53    _ifstat -> empty
Rule 54    forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
Rule 55    statelist -> statement _statelist
Rule 56    _statelist -> statelist
Rule 57    _statelist -> empty
Rule 58    allocexpression -> NEW _allocexpression
Rule 59    _allocexpression -> INT allocexpression_line
Rule 60    _allocexpression -> FLOAT allocexpression_line
Rule 61    _allocexpression -> STRING allocexpression_line
Rule 62    allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line
Rule 63    _allocexpression_line -> allocexpression_line
Rule 64    _allocexpression_line -> empty
Rule 65    expression -> numexpression _expression
Rule 66    _expression -> LESS_THAN numexpression
Rule 67    _expression -> GREATER_THAN numexpression
Rule 68    _expression -> LESS_EQUAL_THAN numexpression
Rule 69    _expression -> GREATER_EQUAL_THAN numexpression
Rule 70    _expression -> EQUAL_TO numexpression
Rule 71    _expression -> NOT_EQUAL_TO numexpression
Rule 72    _expression -> empty
Rule 73    numexpression -> term numexpression_line
Rule 74    numexpression_line -> PLUS term numexpression_line
Rule 75    numexpression_line -> MINUS term numexpression_line
Rule 76    numexpression_line -> empty
Rule 77    term -> unaryexpr term_line
Rule 78    term_line -> TIMES unaryexpr term_line
Rule 79    term_line -> DIVIDE unaryexpr term_line
Rule 80    term_line -> MODULO unaryexpr term_line
Rule 81    term_line -> empty
Rule 82    unaryexpr -> factor
Rule 83    unaryexpr -> PLUS factor
Rule 84    unaryexpr -> MINUS factor
Rule 85    factor -> _node_int_constant
Rule 86    factor -> _node_float_constant
Rule 87    factor -> _node_str_constant
Rule 88    factor -> _node_null_constant
Rule 89    factor -> lvalue
Rule 90    factor -> LPAREN numexpression RPAREN
Rule 91    _node_int_constant -> INT_CONSTANT
Rule 92    _node_float_constant -> FLOAT_CONSTANT
Rule 93    _node_str_constant -> STRING_CONSTANT
Rule 94    _node_null_constant -> NULL
Rule 95    lvalue -> IDENT lvalue_line
Rule 96    lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line
Rule 97    lvalue_line -> empty
Rule 98    make_scope -> <empty>
Rule 99    make_loop_scope -> <empty>
Rule 100   make_loop_label -> <empty>
Rule 101   make_expression_goto -> expression
Rule 102   check_loop_scope -> <empty>
Rule 103   close_scope -> <empty>
Rule 104   empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 29
BREAK                : 22
COMMA                : 12 46
DEFINE               : 7
DIVIDE               : 79
ELSE                 : 52
EQUAL_TO             : 70
FLOAT                : 9 25 60
FLOAT_CONSTANT       : 92
FOR                  : 54
GREATER_EQUAL_THAN   : 69
GREATER_THAN         : 67
IDENT                : 7 8 9 10 24 25 26 33 35 44 95
IF                   : 51
INT                  : 8 24 59
INT_CONSTANT         : 27 91
LBRACES              : 7 21 51
LBRACKET             : 27 62 96
LESS_EQUAL_THAN      : 68
LESS_THAN            : 66
LPAREN               : 7 41 43 51 54 90
MINUS                : 31 75 84
MODULO               : 80
NEW                  : 58
NOT_EQUAL_TO         : 71
NULL                 : 94
PLUS                 : 30 74 83
PRINT                : 48
RBRACES              : 7 21 51
RBRACKET             : 27 62 96
READ                 : 49
RETURN               : 50
RPAREN               : 7 41 43 51 54 90
SEMICOLON            : 14 15 16 17 18 22 23 54 54
STRING               : 10 26 61
STRING_CONSTANT      : 93
TIMES                : 78
error                : 

Nonterminals, with rules where they appear

___atribstat         : 33
__atribstat          : 32 36
_allocexpression     : 58
_allocexpression_line : 62
_atribstat           : 29
_atribstat_help      : 30 31
_expression          : 35 37 38 39 40 41 42 65
_funclist            : 4
_ifstat              : 51
_node_float_constant : 38 86
_node_int_constant   : 37 85
_node_null_constant  : 40 88
_node_str_constant   : 39 87
_paramlist           : 8 9 10
_paramlistcall       : 44
_statelist           : 55
allocexpression      : 34
allocexpression_line : 59 60 61 63
atribstat            : 15 54 54
check_loop_scope     : 22
close_scope          : 1 2 3 7 51 52 54
empty                : 3 6 11 13 28 45 47 53 57 64 72 76 81 97
expression           : 48 101
factor               : 82 83 84
forstat              : 20
funcdef              : 4
funclist             : 2 5
ifstat               : 19
lvalue               : 29 49 89
lvalue_line          : 35 42 95 96
make_expression_goto : 51 54
make_loop_label      : 54
make_loop_scope      : 54
make_scope           : 1 2 3 7 51 52
numexpression        : 41 62 65 66 67 68 69 70 71 90 96
numexpression_line   : 35 37 38 39 40 41 42 73 74 75
paramlist            : 7 12
paramlistcall        : 43 46
printstat            : 16
program              : 0
readstat             : 17
returnstat           : 18
statelist            : 7 21 51 56
statement            : 1 52 54 55
term                 : 73 74 75
term_line            : 35 37 38 39 40 41 42 77 78 79 80
unaryexpr            : 77 78 79 80
vardecl              : 14
vardecl_line         : 24 25 26 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . make_scope statement close_scope
    (2) program -> . make_scope funclist close_scope
    (3) program -> . make_scope empty close_scope
    (98) make_scope -> .

    LBRACES         reduce using rule 98 (make_scope -> .)
    SEMICOLON       reduce using rule 98 (make_scope -> .)
    INT             reduce using rule 98 (make_scope -> .)
    FLOAT           reduce using rule 98 (make_scope -> .)
    STRING          reduce using rule 98 (make_scope -> .)
    PRINT           reduce using rule 98 (make_scope -> .)
    READ            reduce using rule 98 (make_scope -> .)
    RETURN          reduce using rule 98 (make_scope -> .)
    IF              reduce using rule 98 (make_scope -> .)
    FOR             reduce using rule 98 (make_scope -> .)
    DEFINE          reduce using rule 98 (make_scope -> .)
    IDENT           reduce using rule 98 (make_scope -> .)
    BREAK           reduce using rule 98 (make_scope -> .)
    $end            reduce using rule 98 (make_scope -> .)

    program                        shift and go to state 1
    make_scope                     shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> make_scope . statement close_scope
    (2) program -> make_scope . funclist close_scope
    (3) program -> make_scope . empty close_scope
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (4) funclist -> . funcdef _funclist
    (104) empty -> .
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (7) funcdef -> . DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope
    (95) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    $end            reduce using rule 104 (empty -> .)
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    DEFINE          shift and go to state 27
    IDENT           shift and go to state 18

    statement                      shift and go to state 3
    funclist                       shift and go to state 4
    empty                          shift and go to state 5
    vardecl                        shift and go to state 6
    atribstat                      shift and go to state 8
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    funcdef                        shift and go to state 16
    lvalue                         shift and go to state 21

state 3

    (1) program -> make_scope statement . close_scope
    (103) close_scope -> .

    $end            reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 28

state 4

    (2) program -> make_scope funclist . close_scope
    (103) close_scope -> .

    $end            reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 29

state 5

    (3) program -> make_scope empty . close_scope
    (103) close_scope -> .

    $end            reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 30

state 6

    (14) statement -> vardecl . SEMICOLON

    SEMICOLON       shift and go to state 31


state 7

    (23) statement -> SEMICOLON .

    $end            reduce using rule 23 (statement -> SEMICOLON .)
    LBRACES         reduce using rule 23 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 23 (statement -> SEMICOLON .)
    INT             reduce using rule 23 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 23 (statement -> SEMICOLON .)
    STRING          reduce using rule 23 (statement -> SEMICOLON .)
    PRINT           reduce using rule 23 (statement -> SEMICOLON .)
    READ            reduce using rule 23 (statement -> SEMICOLON .)
    RETURN          reduce using rule 23 (statement -> SEMICOLON .)
    IF              reduce using rule 23 (statement -> SEMICOLON .)
    FOR             reduce using rule 23 (statement -> SEMICOLON .)
    IDENT           reduce using rule 23 (statement -> SEMICOLON .)
    BREAK           reduce using rule 23 (statement -> SEMICOLON .)
    RBRACES         reduce using rule 23 (statement -> SEMICOLON .)


state 8

    (15) statement -> atribstat . SEMICOLON

    SEMICOLON       shift and go to state 32


state 9

    (16) statement -> printstat . SEMICOLON

    SEMICOLON       shift and go to state 33


state 10

    (17) statement -> readstat . SEMICOLON

    SEMICOLON       shift and go to state 34


state 11

    (18) statement -> returnstat . SEMICOLON

    SEMICOLON       shift and go to state 35


state 12

    (19) statement -> ifstat .

    $end            reduce using rule 19 (statement -> ifstat .)
    LBRACES         reduce using rule 19 (statement -> ifstat .)
    SEMICOLON       reduce using rule 19 (statement -> ifstat .)
    INT             reduce using rule 19 (statement -> ifstat .)
    FLOAT           reduce using rule 19 (statement -> ifstat .)
    STRING          reduce using rule 19 (statement -> ifstat .)
    PRINT           reduce using rule 19 (statement -> ifstat .)
    READ            reduce using rule 19 (statement -> ifstat .)
    RETURN          reduce using rule 19 (statement -> ifstat .)
    IF              reduce using rule 19 (statement -> ifstat .)
    FOR             reduce using rule 19 (statement -> ifstat .)
    IDENT           reduce using rule 19 (statement -> ifstat .)
    BREAK           reduce using rule 19 (statement -> ifstat .)
    RBRACES         reduce using rule 19 (statement -> ifstat .)


state 13

    (20) statement -> forstat .

    $end            reduce using rule 20 (statement -> forstat .)
    LBRACES         reduce using rule 20 (statement -> forstat .)
    SEMICOLON       reduce using rule 20 (statement -> forstat .)
    INT             reduce using rule 20 (statement -> forstat .)
    FLOAT           reduce using rule 20 (statement -> forstat .)
    STRING          reduce using rule 20 (statement -> forstat .)
    PRINT           reduce using rule 20 (statement -> forstat .)
    READ            reduce using rule 20 (statement -> forstat .)
    RETURN          reduce using rule 20 (statement -> forstat .)
    IF              reduce using rule 20 (statement -> forstat .)
    FOR             reduce using rule 20 (statement -> forstat .)
    IDENT           reduce using rule 20 (statement -> forstat .)
    BREAK           reduce using rule 20 (statement -> forstat .)
    RBRACES         reduce using rule 20 (statement -> forstat .)


state 14

    (21) statement -> LBRACES . statelist RBRACES
    (55) statelist -> . statement _statelist
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (95) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    IDENT           shift and go to state 18

    statelist                      shift and go to state 36
    statement                      shift and go to state 37
    vardecl                        shift and go to state 6
    atribstat                      shift and go to state 8
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    lvalue                         shift and go to state 21

state 15

    (22) statement -> check_loop_scope . BREAK SEMICOLON

    BREAK           shift and go to state 38


state 16

    (4) funclist -> funcdef . _funclist
    (5) _funclist -> . funclist
    (6) _funclist -> . empty
    (4) funclist -> . funcdef _funclist
    (104) empty -> .
    (7) funcdef -> . DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope

    $end            reduce using rule 104 (empty -> .)
    DEFINE          shift and go to state 27

    funcdef                        shift and go to state 16
    _funclist                      shift and go to state 39
    funclist                       shift and go to state 40
    empty                          shift and go to state 41

state 17

    (24) vardecl -> INT . IDENT vardecl_line

    IDENT           shift and go to state 42


state 18

    (95) lvalue -> IDENT . lvalue_line
    (96) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (97) lvalue_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 44
    ASSIGN          reduce using rule 104 (empty -> .)
    TIMES           reduce using rule 104 (empty -> .)
    DIVIDE          reduce using rule 104 (empty -> .)
    MODULO          reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    lvalue_line                    shift and go to state 43
    empty                          shift and go to state 45

state 19

    (25) vardecl -> FLOAT . IDENT vardecl_line

    IDENT           shift and go to state 46


state 20

    (26) vardecl -> STRING . IDENT vardecl_line

    IDENT           shift and go to state 47


state 21

    (29) atribstat -> lvalue . ASSIGN _atribstat

    ASSIGN          shift and go to state 48


state 22

    (48) printstat -> PRINT . expression
    (65) expression -> . numexpression _expression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    expression                     shift and go to state 49
    numexpression                  shift and go to state 50
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 23

    (49) readstat -> READ . lvalue
    (95) lvalue -> . IDENT lvalue_line

    IDENT           shift and go to state 18

    lvalue                         shift and go to state 66

state 24

    (50) returnstat -> RETURN .

    SEMICOLON       reduce using rule 50 (returnstat -> RETURN .)


state 25

    (51) ifstat -> IF . make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (98) make_scope -> .

    LPAREN          reduce using rule 98 (make_scope -> .)

    make_scope                     shift and go to state 67

state 26

    (54) forstat -> FOR . make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (99) make_loop_scope -> .

    LPAREN          reduce using rule 99 (make_loop_scope -> .)

    make_loop_scope                shift and go to state 68

state 27

    (7) funcdef -> DEFINE . IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope

    IDENT           shift and go to state 69


state 28

    (1) program -> make_scope statement close_scope .

    $end            reduce using rule 1 (program -> make_scope statement close_scope .)


state 29

    (2) program -> make_scope funclist close_scope .

    $end            reduce using rule 2 (program -> make_scope funclist close_scope .)


state 30

    (3) program -> make_scope empty close_scope .

    $end            reduce using rule 3 (program -> make_scope empty close_scope .)


state 31

    (14) statement -> vardecl SEMICOLON .

    $end            reduce using rule 14 (statement -> vardecl SEMICOLON .)
    LBRACES         reduce using rule 14 (statement -> vardecl SEMICOLON .)
    SEMICOLON       reduce using rule 14 (statement -> vardecl SEMICOLON .)
    INT             reduce using rule 14 (statement -> vardecl SEMICOLON .)
    FLOAT           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    STRING          reduce using rule 14 (statement -> vardecl SEMICOLON .)
    PRINT           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    READ            reduce using rule 14 (statement -> vardecl SEMICOLON .)
    RETURN          reduce using rule 14 (statement -> vardecl SEMICOLON .)
    IF              reduce using rule 14 (statement -> vardecl SEMICOLON .)
    FOR             reduce using rule 14 (statement -> vardecl SEMICOLON .)
    IDENT           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    BREAK           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    RBRACES         reduce using rule 14 (statement -> vardecl SEMICOLON .)


state 32

    (15) statement -> atribstat SEMICOLON .

    $end            reduce using rule 15 (statement -> atribstat SEMICOLON .)
    LBRACES         reduce using rule 15 (statement -> atribstat SEMICOLON .)
    SEMICOLON       reduce using rule 15 (statement -> atribstat SEMICOLON .)
    INT             reduce using rule 15 (statement -> atribstat SEMICOLON .)
    FLOAT           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    STRING          reduce using rule 15 (statement -> atribstat SEMICOLON .)
    PRINT           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    READ            reduce using rule 15 (statement -> atribstat SEMICOLON .)
    RETURN          reduce using rule 15 (statement -> atribstat SEMICOLON .)
    IF              reduce using rule 15 (statement -> atribstat SEMICOLON .)
    FOR             reduce using rule 15 (statement -> atribstat SEMICOLON .)
    IDENT           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    BREAK           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    RBRACES         reduce using rule 15 (statement -> atribstat SEMICOLON .)


state 33

    (16) statement -> printstat SEMICOLON .

    $end            reduce using rule 16 (statement -> printstat SEMICOLON .)
    LBRACES         reduce using rule 16 (statement -> printstat SEMICOLON .)
    SEMICOLON       reduce using rule 16 (statement -> printstat SEMICOLON .)
    INT             reduce using rule 16 (statement -> printstat SEMICOLON .)
    FLOAT           reduce using rule 16 (statement -> printstat SEMICOLON .)
    STRING          reduce using rule 16 (statement -> printstat SEMICOLON .)
    PRINT           reduce using rule 16 (statement -> printstat SEMICOLON .)
    READ            reduce using rule 16 (statement -> printstat SEMICOLON .)
    RETURN          reduce using rule 16 (statement -> printstat SEMICOLON .)
    IF              reduce using rule 16 (statement -> printstat SEMICOLON .)
    FOR             reduce using rule 16 (statement -> printstat SEMICOLON .)
    IDENT           reduce using rule 16 (statement -> printstat SEMICOLON .)
    BREAK           reduce using rule 16 (statement -> printstat SEMICOLON .)
    RBRACES         reduce using rule 16 (statement -> printstat SEMICOLON .)


state 34

    (17) statement -> readstat SEMICOLON .

    $end            reduce using rule 17 (statement -> readstat SEMICOLON .)
    LBRACES         reduce using rule 17 (statement -> readstat SEMICOLON .)
    SEMICOLON       reduce using rule 17 (statement -> readstat SEMICOLON .)
    INT             reduce using rule 17 (statement -> readstat SEMICOLON .)
    FLOAT           reduce using rule 17 (statement -> readstat SEMICOLON .)
    STRING          reduce using rule 17 (statement -> readstat SEMICOLON .)
    PRINT           reduce using rule 17 (statement -> readstat SEMICOLON .)
    READ            reduce using rule 17 (statement -> readstat SEMICOLON .)
    RETURN          reduce using rule 17 (statement -> readstat SEMICOLON .)
    IF              reduce using rule 17 (statement -> readstat SEMICOLON .)
    FOR             reduce using rule 17 (statement -> readstat SEMICOLON .)
    IDENT           reduce using rule 17 (statement -> readstat SEMICOLON .)
    BREAK           reduce using rule 17 (statement -> readstat SEMICOLON .)
    RBRACES         reduce using rule 17 (statement -> readstat SEMICOLON .)


state 35

    (18) statement -> returnstat SEMICOLON .

    $end            reduce using rule 18 (statement -> returnstat SEMICOLON .)
    LBRACES         reduce using rule 18 (statement -> returnstat SEMICOLON .)
    SEMICOLON       reduce using rule 18 (statement -> returnstat SEMICOLON .)
    INT             reduce using rule 18 (statement -> returnstat SEMICOLON .)
    FLOAT           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    STRING          reduce using rule 18 (statement -> returnstat SEMICOLON .)
    PRINT           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    READ            reduce using rule 18 (statement -> returnstat SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> returnstat SEMICOLON .)
    IF              reduce using rule 18 (statement -> returnstat SEMICOLON .)
    FOR             reduce using rule 18 (statement -> returnstat SEMICOLON .)
    IDENT           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    BREAK           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    RBRACES         reduce using rule 18 (statement -> returnstat SEMICOLON .)


state 36

    (21) statement -> LBRACES statelist . RBRACES

    RBRACES         shift and go to state 70


state 37

    (55) statelist -> statement . _statelist
    (56) _statelist -> . statelist
    (57) _statelist -> . empty
    (55) statelist -> . statement _statelist
    (104) empty -> .
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (95) lvalue -> . IDENT lvalue_line

    RBRACES         reduce using rule 104 (empty -> .)
    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    IDENT           shift and go to state 18

    statement                      shift and go to state 37
    _statelist                     shift and go to state 71
    statelist                      shift and go to state 72
    empty                          shift and go to state 73
    vardecl                        shift and go to state 6
    atribstat                      shift and go to state 8
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    lvalue                         shift and go to state 21

state 38

    (22) statement -> check_loop_scope BREAK . SEMICOLON

    SEMICOLON       shift and go to state 74


state 39

    (4) funclist -> funcdef _funclist .

    $end            reduce using rule 4 (funclist -> funcdef _funclist .)


state 40

    (5) _funclist -> funclist .

    $end            reduce using rule 5 (_funclist -> funclist .)


state 41

    (6) _funclist -> empty .

    $end            reduce using rule 6 (_funclist -> empty .)


state 42

    (24) vardecl -> INT IDENT . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 76
    SEMICOLON       reduce using rule 104 (empty -> .)

    vardecl_line                   shift and go to state 75
    empty                          shift and go to state 77

state 43

    (95) lvalue -> IDENT lvalue_line .

    ASSIGN          reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    TIMES           reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    DIVIDE          reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    MODULO          reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    PLUS            reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    MINUS           reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    LESS_THAN       reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    GREATER_THAN    reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    LESS_EQUAL_THAN reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    GREATER_EQUAL_THAN reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    EQUAL_TO        reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    NOT_EQUAL_TO    reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    SEMICOLON       reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    RBRACKET        reduce using rule 95 (lvalue -> IDENT lvalue_line .)
    RPAREN          reduce using rule 95 (lvalue -> IDENT lvalue_line .)


state 44

    (96) lvalue_line -> LBRACKET . numexpression RBRACKET lvalue_line
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 78
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 45

    (97) lvalue_line -> empty .

    ASSIGN          reduce using rule 97 (lvalue_line -> empty .)
    TIMES           reduce using rule 97 (lvalue_line -> empty .)
    DIVIDE          reduce using rule 97 (lvalue_line -> empty .)
    MODULO          reduce using rule 97 (lvalue_line -> empty .)
    PLUS            reduce using rule 97 (lvalue_line -> empty .)
    MINUS           reduce using rule 97 (lvalue_line -> empty .)
    LESS_THAN       reduce using rule 97 (lvalue_line -> empty .)
    GREATER_THAN    reduce using rule 97 (lvalue_line -> empty .)
    LESS_EQUAL_THAN reduce using rule 97 (lvalue_line -> empty .)
    GREATER_EQUAL_THAN reduce using rule 97 (lvalue_line -> empty .)
    EQUAL_TO        reduce using rule 97 (lvalue_line -> empty .)
    NOT_EQUAL_TO    reduce using rule 97 (lvalue_line -> empty .)
    SEMICOLON       reduce using rule 97 (lvalue_line -> empty .)
    RBRACKET        reduce using rule 97 (lvalue_line -> empty .)
    RPAREN          reduce using rule 97 (lvalue_line -> empty .)


state 46

    (25) vardecl -> FLOAT IDENT . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 76
    SEMICOLON       reduce using rule 104 (empty -> .)

    vardecl_line                   shift and go to state 79
    empty                          shift and go to state 77

state 47

    (26) vardecl -> STRING IDENT . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 76
    SEMICOLON       reduce using rule 104 (empty -> .)

    vardecl_line                   shift and go to state 80
    empty                          shift and go to state 77

state 48

    (29) atribstat -> lvalue ASSIGN . _atribstat
    (30) _atribstat -> . PLUS _atribstat_help
    (31) _atribstat -> . MINUS _atribstat_help
    (32) _atribstat -> . __atribstat
    (33) _atribstat -> . IDENT ___atribstat
    (34) _atribstat -> . allocexpression
    (37) __atribstat -> . _node_int_constant term_line numexpression_line _expression
    (38) __atribstat -> . _node_float_constant term_line numexpression_line _expression
    (39) __atribstat -> . _node_str_constant term_line numexpression_line _expression
    (40) __atribstat -> . _node_null_constant term_line numexpression_line _expression
    (41) __atribstat -> . LPAREN numexpression RPAREN term_line numexpression_line _expression
    (58) allocexpression -> . NEW _allocexpression
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL

    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    IDENT           shift and go to state 85
    LPAREN          shift and go to state 91
    NEW             shift and go to state 92
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65

    _atribstat                     shift and go to state 81
    __atribstat                    shift and go to state 84
    allocexpression                shift and go to state 86
    _node_int_constant             shift and go to state 87
    _node_float_constant           shift and go to state 88
    _node_str_constant             shift and go to state 89
    _node_null_constant            shift and go to state 90

state 49

    (48) printstat -> PRINT expression .

    SEMICOLON       reduce using rule 48 (printstat -> PRINT expression .)


state 50

    (65) expression -> numexpression . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 93
    empty                          shift and go to state 100

state 51

    (73) numexpression -> term . numexpression_line
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 101
    empty                          shift and go to state 104

state 52

    (77) term -> unaryexpr . term_line
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 105
    empty                          shift and go to state 109

state 53

    (82) unaryexpr -> factor .

    TIMES           reduce using rule 82 (unaryexpr -> factor .)
    DIVIDE          reduce using rule 82 (unaryexpr -> factor .)
    MODULO          reduce using rule 82 (unaryexpr -> factor .)
    PLUS            reduce using rule 82 (unaryexpr -> factor .)
    MINUS           reduce using rule 82 (unaryexpr -> factor .)
    LESS_THAN       reduce using rule 82 (unaryexpr -> factor .)
    GREATER_THAN    reduce using rule 82 (unaryexpr -> factor .)
    LESS_EQUAL_THAN reduce using rule 82 (unaryexpr -> factor .)
    GREATER_EQUAL_THAN reduce using rule 82 (unaryexpr -> factor .)
    EQUAL_TO        reduce using rule 82 (unaryexpr -> factor .)
    NOT_EQUAL_TO    reduce using rule 82 (unaryexpr -> factor .)
    SEMICOLON       reduce using rule 82 (unaryexpr -> factor .)
    RBRACKET        reduce using rule 82 (unaryexpr -> factor .)
    RPAREN          reduce using rule 82 (unaryexpr -> factor .)


state 54

    (83) unaryexpr -> PLUS . factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    factor                         shift and go to state 110
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 55

    (84) unaryexpr -> MINUS . factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    factor                         shift and go to state 111
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 56

    (85) factor -> _node_int_constant .

    TIMES           reduce using rule 85 (factor -> _node_int_constant .)
    DIVIDE          reduce using rule 85 (factor -> _node_int_constant .)
    MODULO          reduce using rule 85 (factor -> _node_int_constant .)
    PLUS            reduce using rule 85 (factor -> _node_int_constant .)
    MINUS           reduce using rule 85 (factor -> _node_int_constant .)
    LESS_THAN       reduce using rule 85 (factor -> _node_int_constant .)
    GREATER_THAN    reduce using rule 85 (factor -> _node_int_constant .)
    LESS_EQUAL_THAN reduce using rule 85 (factor -> _node_int_constant .)
    GREATER_EQUAL_THAN reduce using rule 85 (factor -> _node_int_constant .)
    EQUAL_TO        reduce using rule 85 (factor -> _node_int_constant .)
    NOT_EQUAL_TO    reduce using rule 85 (factor -> _node_int_constant .)
    SEMICOLON       reduce using rule 85 (factor -> _node_int_constant .)
    RBRACKET        reduce using rule 85 (factor -> _node_int_constant .)
    RPAREN          reduce using rule 85 (factor -> _node_int_constant .)


state 57

    (86) factor -> _node_float_constant .

    TIMES           reduce using rule 86 (factor -> _node_float_constant .)
    DIVIDE          reduce using rule 86 (factor -> _node_float_constant .)
    MODULO          reduce using rule 86 (factor -> _node_float_constant .)
    PLUS            reduce using rule 86 (factor -> _node_float_constant .)
    MINUS           reduce using rule 86 (factor -> _node_float_constant .)
    LESS_THAN       reduce using rule 86 (factor -> _node_float_constant .)
    GREATER_THAN    reduce using rule 86 (factor -> _node_float_constant .)
    LESS_EQUAL_THAN reduce using rule 86 (factor -> _node_float_constant .)
    GREATER_EQUAL_THAN reduce using rule 86 (factor -> _node_float_constant .)
    EQUAL_TO        reduce using rule 86 (factor -> _node_float_constant .)
    NOT_EQUAL_TO    reduce using rule 86 (factor -> _node_float_constant .)
    SEMICOLON       reduce using rule 86 (factor -> _node_float_constant .)
    RBRACKET        reduce using rule 86 (factor -> _node_float_constant .)
    RPAREN          reduce using rule 86 (factor -> _node_float_constant .)


state 58

    (87) factor -> _node_str_constant .

    TIMES           reduce using rule 87 (factor -> _node_str_constant .)
    DIVIDE          reduce using rule 87 (factor -> _node_str_constant .)
    MODULO          reduce using rule 87 (factor -> _node_str_constant .)
    PLUS            reduce using rule 87 (factor -> _node_str_constant .)
    MINUS           reduce using rule 87 (factor -> _node_str_constant .)
    LESS_THAN       reduce using rule 87 (factor -> _node_str_constant .)
    GREATER_THAN    reduce using rule 87 (factor -> _node_str_constant .)
    LESS_EQUAL_THAN reduce using rule 87 (factor -> _node_str_constant .)
    GREATER_EQUAL_THAN reduce using rule 87 (factor -> _node_str_constant .)
    EQUAL_TO        reduce using rule 87 (factor -> _node_str_constant .)
    NOT_EQUAL_TO    reduce using rule 87 (factor -> _node_str_constant .)
    SEMICOLON       reduce using rule 87 (factor -> _node_str_constant .)
    RBRACKET        reduce using rule 87 (factor -> _node_str_constant .)
    RPAREN          reduce using rule 87 (factor -> _node_str_constant .)


state 59

    (88) factor -> _node_null_constant .

    TIMES           reduce using rule 88 (factor -> _node_null_constant .)
    DIVIDE          reduce using rule 88 (factor -> _node_null_constant .)
    MODULO          reduce using rule 88 (factor -> _node_null_constant .)
    PLUS            reduce using rule 88 (factor -> _node_null_constant .)
    MINUS           reduce using rule 88 (factor -> _node_null_constant .)
    LESS_THAN       reduce using rule 88 (factor -> _node_null_constant .)
    GREATER_THAN    reduce using rule 88 (factor -> _node_null_constant .)
    LESS_EQUAL_THAN reduce using rule 88 (factor -> _node_null_constant .)
    GREATER_EQUAL_THAN reduce using rule 88 (factor -> _node_null_constant .)
    EQUAL_TO        reduce using rule 88 (factor -> _node_null_constant .)
    NOT_EQUAL_TO    reduce using rule 88 (factor -> _node_null_constant .)
    SEMICOLON       reduce using rule 88 (factor -> _node_null_constant .)
    RBRACKET        reduce using rule 88 (factor -> _node_null_constant .)
    RPAREN          reduce using rule 88 (factor -> _node_null_constant .)


state 60

    (89) factor -> lvalue .

    TIMES           reduce using rule 89 (factor -> lvalue .)
    DIVIDE          reduce using rule 89 (factor -> lvalue .)
    MODULO          reduce using rule 89 (factor -> lvalue .)
    PLUS            reduce using rule 89 (factor -> lvalue .)
    MINUS           reduce using rule 89 (factor -> lvalue .)
    LESS_THAN       reduce using rule 89 (factor -> lvalue .)
    GREATER_THAN    reduce using rule 89 (factor -> lvalue .)
    LESS_EQUAL_THAN reduce using rule 89 (factor -> lvalue .)
    GREATER_EQUAL_THAN reduce using rule 89 (factor -> lvalue .)
    EQUAL_TO        reduce using rule 89 (factor -> lvalue .)
    NOT_EQUAL_TO    reduce using rule 89 (factor -> lvalue .)
    SEMICOLON       reduce using rule 89 (factor -> lvalue .)
    RBRACKET        reduce using rule 89 (factor -> lvalue .)
    RPAREN          reduce using rule 89 (factor -> lvalue .)


state 61

    (90) factor -> LPAREN . numexpression RPAREN
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 112
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 62

    (91) _node_int_constant -> INT_CONSTANT .

    TIMES           reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    DIVIDE          reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    MODULO          reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    PLUS            reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    MINUS           reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    LESS_THAN       reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    GREATER_THAN    reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    LESS_EQUAL_THAN reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    GREATER_EQUAL_THAN reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    EQUAL_TO        reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    NOT_EQUAL_TO    reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    SEMICOLON       reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    RBRACKET        reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)
    RPAREN          reduce using rule 91 (_node_int_constant -> INT_CONSTANT .)


state 63

    (92) _node_float_constant -> FLOAT_CONSTANT .

    TIMES           reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    DIVIDE          reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    MODULO          reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    PLUS            reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    MINUS           reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    LESS_THAN       reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    GREATER_THAN    reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    LESS_EQUAL_THAN reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    GREATER_EQUAL_THAN reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    EQUAL_TO        reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    NOT_EQUAL_TO    reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    SEMICOLON       reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    RBRACKET        reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)
    RPAREN          reduce using rule 92 (_node_float_constant -> FLOAT_CONSTANT .)


state 64

    (93) _node_str_constant -> STRING_CONSTANT .

    TIMES           reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    DIVIDE          reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    MODULO          reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    PLUS            reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    MINUS           reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    LESS_THAN       reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    GREATER_THAN    reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    LESS_EQUAL_THAN reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    GREATER_EQUAL_THAN reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    EQUAL_TO        reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    NOT_EQUAL_TO    reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    SEMICOLON       reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    RBRACKET        reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)
    RPAREN          reduce using rule 93 (_node_str_constant -> STRING_CONSTANT .)


state 65

    (94) _node_null_constant -> NULL .

    TIMES           reduce using rule 94 (_node_null_constant -> NULL .)
    DIVIDE          reduce using rule 94 (_node_null_constant -> NULL .)
    MODULO          reduce using rule 94 (_node_null_constant -> NULL .)
    PLUS            reduce using rule 94 (_node_null_constant -> NULL .)
    MINUS           reduce using rule 94 (_node_null_constant -> NULL .)
    LESS_THAN       reduce using rule 94 (_node_null_constant -> NULL .)
    GREATER_THAN    reduce using rule 94 (_node_null_constant -> NULL .)
    LESS_EQUAL_THAN reduce using rule 94 (_node_null_constant -> NULL .)
    GREATER_EQUAL_THAN reduce using rule 94 (_node_null_constant -> NULL .)
    EQUAL_TO        reduce using rule 94 (_node_null_constant -> NULL .)
    NOT_EQUAL_TO    reduce using rule 94 (_node_null_constant -> NULL .)
    SEMICOLON       reduce using rule 94 (_node_null_constant -> NULL .)
    RBRACKET        reduce using rule 94 (_node_null_constant -> NULL .)
    RPAREN          reduce using rule 94 (_node_null_constant -> NULL .)


state 66

    (49) readstat -> READ lvalue .

    SEMICOLON       reduce using rule 49 (readstat -> READ lvalue .)


state 67

    (51) ifstat -> IF make_scope . LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat

    LPAREN          shift and go to state 113


state 68

    (54) forstat -> FOR make_loop_scope . LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope

    LPAREN          shift and go to state 114


state 69

    (7) funcdef -> DEFINE IDENT . make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope
    (98) make_scope -> .

    LPAREN          reduce using rule 98 (make_scope -> .)

    make_scope                     shift and go to state 115

state 70

    (21) statement -> LBRACES statelist RBRACES .

    $end            reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    LBRACES         reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    SEMICOLON       reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    INT             reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    FLOAT           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    STRING          reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    PRINT           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    READ            reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    RETURN          reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    IF              reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    FOR             reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    IDENT           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    BREAK           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    RBRACES         reduce using rule 21 (statement -> LBRACES statelist RBRACES .)


state 71

    (55) statelist -> statement _statelist .

    RBRACES         reduce using rule 55 (statelist -> statement _statelist .)


state 72

    (56) _statelist -> statelist .

    RBRACES         reduce using rule 56 (_statelist -> statelist .)


state 73

    (57) _statelist -> empty .

    RBRACES         reduce using rule 57 (_statelist -> empty .)


state 74

    (22) statement -> check_loop_scope BREAK SEMICOLON .

    $end            reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    LBRACES         reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    INT             reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    FLOAT           reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    STRING          reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    PRINT           reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    READ            reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    RETURN          reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    IF              reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    FOR             reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    IDENT           reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    BREAK           reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)
    RBRACES         reduce using rule 22 (statement -> check_loop_scope BREAK SEMICOLON .)


state 75

    (24) vardecl -> INT IDENT vardecl_line .

    SEMICOLON       reduce using rule 24 (vardecl -> INT IDENT vardecl_line .)


state 76

    (27) vardecl_line -> LBRACKET . INT_CONSTANT RBRACKET vardecl_line

    INT_CONSTANT    shift and go to state 116


state 77

    (28) vardecl_line -> empty .

    SEMICOLON       reduce using rule 28 (vardecl_line -> empty .)


state 78

    (96) lvalue_line -> LBRACKET numexpression . RBRACKET lvalue_line

    RBRACKET        shift and go to state 117


state 79

    (25) vardecl -> FLOAT IDENT vardecl_line .

    SEMICOLON       reduce using rule 25 (vardecl -> FLOAT IDENT vardecl_line .)


state 80

    (26) vardecl -> STRING IDENT vardecl_line .

    SEMICOLON       reduce using rule 26 (vardecl -> STRING IDENT vardecl_line .)


state 81

    (29) atribstat -> lvalue ASSIGN _atribstat .

    SEMICOLON       reduce using rule 29 (atribstat -> lvalue ASSIGN _atribstat .)
    RPAREN          reduce using rule 29 (atribstat -> lvalue ASSIGN _atribstat .)


state 82

    (30) _atribstat -> PLUS . _atribstat_help
    (35) _atribstat_help -> . IDENT lvalue_line term_line numexpression_line _expression
    (36) _atribstat_help -> . __atribstat
    (37) __atribstat -> . _node_int_constant term_line numexpression_line _expression
    (38) __atribstat -> . _node_float_constant term_line numexpression_line _expression
    (39) __atribstat -> . _node_str_constant term_line numexpression_line _expression
    (40) __atribstat -> . _node_null_constant term_line numexpression_line _expression
    (41) __atribstat -> . LPAREN numexpression RPAREN term_line numexpression_line _expression
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL

    IDENT           shift and go to state 119
    LPAREN          shift and go to state 91
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65

    _atribstat_help                shift and go to state 118
    __atribstat                    shift and go to state 120
    _node_int_constant             shift and go to state 87
    _node_float_constant           shift and go to state 88
    _node_str_constant             shift and go to state 89
    _node_null_constant            shift and go to state 90

state 83

    (31) _atribstat -> MINUS . _atribstat_help
    (35) _atribstat_help -> . IDENT lvalue_line term_line numexpression_line _expression
    (36) _atribstat_help -> . __atribstat
    (37) __atribstat -> . _node_int_constant term_line numexpression_line _expression
    (38) __atribstat -> . _node_float_constant term_line numexpression_line _expression
    (39) __atribstat -> . _node_str_constant term_line numexpression_line _expression
    (40) __atribstat -> . _node_null_constant term_line numexpression_line _expression
    (41) __atribstat -> . LPAREN numexpression RPAREN term_line numexpression_line _expression
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL

    IDENT           shift and go to state 119
    LPAREN          shift and go to state 91
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65

    _atribstat_help                shift and go to state 121
    __atribstat                    shift and go to state 120
    _node_int_constant             shift and go to state 87
    _node_float_constant           shift and go to state 88
    _node_str_constant             shift and go to state 89
    _node_null_constant            shift and go to state 90

state 84

    (32) _atribstat -> __atribstat .

    SEMICOLON       reduce using rule 32 (_atribstat -> __atribstat .)
    RPAREN          reduce using rule 32 (_atribstat -> __atribstat .)


state 85

    (33) _atribstat -> IDENT . ___atribstat
    (42) ___atribstat -> . lvalue_line term_line numexpression_line _expression
    (43) ___atribstat -> . LPAREN paramlistcall RPAREN
    (96) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (97) lvalue_line -> . empty
    (104) empty -> .

    LPAREN          shift and go to state 124
    LBRACKET        shift and go to state 44
    TIMES           reduce using rule 104 (empty -> .)
    DIVIDE          reduce using rule 104 (empty -> .)
    MODULO          reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    ___atribstat                   shift and go to state 122
    lvalue_line                    shift and go to state 123
    empty                          shift and go to state 45

state 86

    (34) _atribstat -> allocexpression .

    SEMICOLON       reduce using rule 34 (_atribstat -> allocexpression .)
    RPAREN          reduce using rule 34 (_atribstat -> allocexpression .)


state 87

    (37) __atribstat -> _node_int_constant . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 125
    empty                          shift and go to state 109

state 88

    (38) __atribstat -> _node_float_constant . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 126
    empty                          shift and go to state 109

state 89

    (39) __atribstat -> _node_str_constant . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 127
    empty                          shift and go to state 109

state 90

    (40) __atribstat -> _node_null_constant . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 128
    empty                          shift and go to state 109

state 91

    (41) __atribstat -> LPAREN . numexpression RPAREN term_line numexpression_line _expression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 129
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 92

    (58) allocexpression -> NEW . _allocexpression
    (59) _allocexpression -> . INT allocexpression_line
    (60) _allocexpression -> . FLOAT allocexpression_line
    (61) _allocexpression -> . STRING allocexpression_line

    INT             shift and go to state 131
    FLOAT           shift and go to state 132
    STRING          shift and go to state 133

    _allocexpression               shift and go to state 130

state 93

    (65) expression -> numexpression _expression .

    SEMICOLON       reduce using rule 65 (expression -> numexpression _expression .)
    RPAREN          reduce using rule 65 (expression -> numexpression _expression .)


state 94

    (66) _expression -> LESS_THAN . numexpression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 134
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 95

    (67) _expression -> GREATER_THAN . numexpression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 135
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 96

    (68) _expression -> LESS_EQUAL_THAN . numexpression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 136
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 97

    (69) _expression -> GREATER_EQUAL_THAN . numexpression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 137
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 98

    (70) _expression -> EQUAL_TO . numexpression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 138
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 99

    (71) _expression -> NOT_EQUAL_TO . numexpression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 139
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 100

    (72) _expression -> empty .

    SEMICOLON       reduce using rule 72 (_expression -> empty .)
    RPAREN          reduce using rule 72 (_expression -> empty .)


state 101

    (73) numexpression -> term numexpression_line .

    LESS_THAN       reduce using rule 73 (numexpression -> term numexpression_line .)
    GREATER_THAN    reduce using rule 73 (numexpression -> term numexpression_line .)
    LESS_EQUAL_THAN reduce using rule 73 (numexpression -> term numexpression_line .)
    GREATER_EQUAL_THAN reduce using rule 73 (numexpression -> term numexpression_line .)
    EQUAL_TO        reduce using rule 73 (numexpression -> term numexpression_line .)
    NOT_EQUAL_TO    reduce using rule 73 (numexpression -> term numexpression_line .)
    SEMICOLON       reduce using rule 73 (numexpression -> term numexpression_line .)
    RBRACKET        reduce using rule 73 (numexpression -> term numexpression_line .)
    RPAREN          reduce using rule 73 (numexpression -> term numexpression_line .)


state 102

    (74) numexpression_line -> PLUS . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    term                           shift and go to state 140
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 103

    (75) numexpression_line -> MINUS . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    term                           shift and go to state 141
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 104

    (76) numexpression_line -> empty .

    LESS_THAN       reduce using rule 76 (numexpression_line -> empty .)
    GREATER_THAN    reduce using rule 76 (numexpression_line -> empty .)
    LESS_EQUAL_THAN reduce using rule 76 (numexpression_line -> empty .)
    GREATER_EQUAL_THAN reduce using rule 76 (numexpression_line -> empty .)
    EQUAL_TO        reduce using rule 76 (numexpression_line -> empty .)
    NOT_EQUAL_TO    reduce using rule 76 (numexpression_line -> empty .)
    SEMICOLON       reduce using rule 76 (numexpression_line -> empty .)
    RBRACKET        reduce using rule 76 (numexpression_line -> empty .)
    RPAREN          reduce using rule 76 (numexpression_line -> empty .)


state 105

    (77) term -> unaryexpr term_line .

    PLUS            reduce using rule 77 (term -> unaryexpr term_line .)
    MINUS           reduce using rule 77 (term -> unaryexpr term_line .)
    LESS_THAN       reduce using rule 77 (term -> unaryexpr term_line .)
    GREATER_THAN    reduce using rule 77 (term -> unaryexpr term_line .)
    LESS_EQUAL_THAN reduce using rule 77 (term -> unaryexpr term_line .)
    GREATER_EQUAL_THAN reduce using rule 77 (term -> unaryexpr term_line .)
    EQUAL_TO        reduce using rule 77 (term -> unaryexpr term_line .)
    NOT_EQUAL_TO    reduce using rule 77 (term -> unaryexpr term_line .)
    SEMICOLON       reduce using rule 77 (term -> unaryexpr term_line .)
    RBRACKET        reduce using rule 77 (term -> unaryexpr term_line .)
    RPAREN          reduce using rule 77 (term -> unaryexpr term_line .)


state 106

    (78) term_line -> TIMES . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    unaryexpr                      shift and go to state 142
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 107

    (79) term_line -> DIVIDE . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    unaryexpr                      shift and go to state 143
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 108

    (80) term_line -> MODULO . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    unaryexpr                      shift and go to state 144
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 109

    (81) term_line -> empty .

    PLUS            reduce using rule 81 (term_line -> empty .)
    MINUS           reduce using rule 81 (term_line -> empty .)
    LESS_THAN       reduce using rule 81 (term_line -> empty .)
    GREATER_THAN    reduce using rule 81 (term_line -> empty .)
    LESS_EQUAL_THAN reduce using rule 81 (term_line -> empty .)
    GREATER_EQUAL_THAN reduce using rule 81 (term_line -> empty .)
    EQUAL_TO        reduce using rule 81 (term_line -> empty .)
    NOT_EQUAL_TO    reduce using rule 81 (term_line -> empty .)
    SEMICOLON       reduce using rule 81 (term_line -> empty .)
    RBRACKET        reduce using rule 81 (term_line -> empty .)
    RPAREN          reduce using rule 81 (term_line -> empty .)


state 110

    (83) unaryexpr -> PLUS factor .

    TIMES           reduce using rule 83 (unaryexpr -> PLUS factor .)
    DIVIDE          reduce using rule 83 (unaryexpr -> PLUS factor .)
    MODULO          reduce using rule 83 (unaryexpr -> PLUS factor .)
    PLUS            reduce using rule 83 (unaryexpr -> PLUS factor .)
    MINUS           reduce using rule 83 (unaryexpr -> PLUS factor .)
    LESS_THAN       reduce using rule 83 (unaryexpr -> PLUS factor .)
    GREATER_THAN    reduce using rule 83 (unaryexpr -> PLUS factor .)
    LESS_EQUAL_THAN reduce using rule 83 (unaryexpr -> PLUS factor .)
    GREATER_EQUAL_THAN reduce using rule 83 (unaryexpr -> PLUS factor .)
    EQUAL_TO        reduce using rule 83 (unaryexpr -> PLUS factor .)
    NOT_EQUAL_TO    reduce using rule 83 (unaryexpr -> PLUS factor .)
    SEMICOLON       reduce using rule 83 (unaryexpr -> PLUS factor .)
    RBRACKET        reduce using rule 83 (unaryexpr -> PLUS factor .)
    RPAREN          reduce using rule 83 (unaryexpr -> PLUS factor .)


state 111

    (84) unaryexpr -> MINUS factor .

    TIMES           reduce using rule 84 (unaryexpr -> MINUS factor .)
    DIVIDE          reduce using rule 84 (unaryexpr -> MINUS factor .)
    MODULO          reduce using rule 84 (unaryexpr -> MINUS factor .)
    PLUS            reduce using rule 84 (unaryexpr -> MINUS factor .)
    MINUS           reduce using rule 84 (unaryexpr -> MINUS factor .)
    LESS_THAN       reduce using rule 84 (unaryexpr -> MINUS factor .)
    GREATER_THAN    reduce using rule 84 (unaryexpr -> MINUS factor .)
    LESS_EQUAL_THAN reduce using rule 84 (unaryexpr -> MINUS factor .)
    GREATER_EQUAL_THAN reduce using rule 84 (unaryexpr -> MINUS factor .)
    EQUAL_TO        reduce using rule 84 (unaryexpr -> MINUS factor .)
    NOT_EQUAL_TO    reduce using rule 84 (unaryexpr -> MINUS factor .)
    SEMICOLON       reduce using rule 84 (unaryexpr -> MINUS factor .)
    RBRACKET        reduce using rule 84 (unaryexpr -> MINUS factor .)
    RPAREN          reduce using rule 84 (unaryexpr -> MINUS factor .)


state 112

    (90) factor -> LPAREN numexpression . RPAREN

    RPAREN          shift and go to state 145


state 113

    (51) ifstat -> IF make_scope LPAREN . make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (101) make_expression_goto -> . expression
    (65) expression -> . numexpression _expression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    make_expression_goto           shift and go to state 146
    expression                     shift and go to state 147
    numexpression                  shift and go to state 50
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 114

    (54) forstat -> FOR make_loop_scope LPAREN . atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (95) lvalue -> . IDENT lvalue_line

    IDENT           shift and go to state 18

    atribstat                      shift and go to state 148
    lvalue                         shift and go to state 21

state 115

    (7) funcdef -> DEFINE IDENT make_scope . LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope

    LPAREN          shift and go to state 149


state 116

    (27) vardecl_line -> LBRACKET INT_CONSTANT . RBRACKET vardecl_line

    RBRACKET        shift and go to state 150


state 117

    (96) lvalue_line -> LBRACKET numexpression RBRACKET . lvalue_line
    (96) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (97) lvalue_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 44
    ASSIGN          reduce using rule 104 (empty -> .)
    TIMES           reduce using rule 104 (empty -> .)
    DIVIDE          reduce using rule 104 (empty -> .)
    MODULO          reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    lvalue_line                    shift and go to state 151
    empty                          shift and go to state 45

state 118

    (30) _atribstat -> PLUS _atribstat_help .

    SEMICOLON       reduce using rule 30 (_atribstat -> PLUS _atribstat_help .)
    RPAREN          reduce using rule 30 (_atribstat -> PLUS _atribstat_help .)


state 119

    (35) _atribstat_help -> IDENT . lvalue_line term_line numexpression_line _expression
    (96) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (97) lvalue_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 44
    TIMES           reduce using rule 104 (empty -> .)
    DIVIDE          reduce using rule 104 (empty -> .)
    MODULO          reduce using rule 104 (empty -> .)
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    lvalue_line                    shift and go to state 152
    empty                          shift and go to state 45

state 120

    (36) _atribstat_help -> __atribstat .

    SEMICOLON       reduce using rule 36 (_atribstat_help -> __atribstat .)
    RPAREN          reduce using rule 36 (_atribstat_help -> __atribstat .)


state 121

    (31) _atribstat -> MINUS _atribstat_help .

    SEMICOLON       reduce using rule 31 (_atribstat -> MINUS _atribstat_help .)
    RPAREN          reduce using rule 31 (_atribstat -> MINUS _atribstat_help .)


state 122

    (33) _atribstat -> IDENT ___atribstat .

    SEMICOLON       reduce using rule 33 (_atribstat -> IDENT ___atribstat .)
    RPAREN          reduce using rule 33 (_atribstat -> IDENT ___atribstat .)


state 123

    (42) ___atribstat -> lvalue_line . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 153
    empty                          shift and go to state 109

state 124

    (43) ___atribstat -> LPAREN . paramlistcall RPAREN
    (44) paramlistcall -> . IDENT _paramlistcall
    (45) paramlistcall -> . empty
    (104) empty -> .

    IDENT           shift and go to state 155
    RPAREN          reduce using rule 104 (empty -> .)

    paramlistcall                  shift and go to state 154
    empty                          shift and go to state 156

state 125

    (37) __atribstat -> _node_int_constant term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 157
    empty                          shift and go to state 104

state 126

    (38) __atribstat -> _node_float_constant term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 158
    empty                          shift and go to state 104

state 127

    (39) __atribstat -> _node_str_constant term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 159
    empty                          shift and go to state 104

state 128

    (40) __atribstat -> _node_null_constant term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 160
    empty                          shift and go to state 104

state 129

    (41) __atribstat -> LPAREN numexpression . RPAREN term_line numexpression_line _expression

    RPAREN          shift and go to state 161


state 130

    (58) allocexpression -> NEW _allocexpression .

    SEMICOLON       reduce using rule 58 (allocexpression -> NEW _allocexpression .)
    RPAREN          reduce using rule 58 (allocexpression -> NEW _allocexpression .)


state 131

    (59) _allocexpression -> INT . allocexpression_line
    (62) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line

    LBRACKET        shift and go to state 163

    allocexpression_line           shift and go to state 162

state 132

    (60) _allocexpression -> FLOAT . allocexpression_line
    (62) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line

    LBRACKET        shift and go to state 163

    allocexpression_line           shift and go to state 164

state 133

    (61) _allocexpression -> STRING . allocexpression_line
    (62) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line

    LBRACKET        shift and go to state 163

    allocexpression_line           shift and go to state 165

state 134

    (66) _expression -> LESS_THAN numexpression .

    SEMICOLON       reduce using rule 66 (_expression -> LESS_THAN numexpression .)
    RPAREN          reduce using rule 66 (_expression -> LESS_THAN numexpression .)


state 135

    (67) _expression -> GREATER_THAN numexpression .

    SEMICOLON       reduce using rule 67 (_expression -> GREATER_THAN numexpression .)
    RPAREN          reduce using rule 67 (_expression -> GREATER_THAN numexpression .)


state 136

    (68) _expression -> LESS_EQUAL_THAN numexpression .

    SEMICOLON       reduce using rule 68 (_expression -> LESS_EQUAL_THAN numexpression .)
    RPAREN          reduce using rule 68 (_expression -> LESS_EQUAL_THAN numexpression .)


state 137

    (69) _expression -> GREATER_EQUAL_THAN numexpression .

    SEMICOLON       reduce using rule 69 (_expression -> GREATER_EQUAL_THAN numexpression .)
    RPAREN          reduce using rule 69 (_expression -> GREATER_EQUAL_THAN numexpression .)


state 138

    (70) _expression -> EQUAL_TO numexpression .

    SEMICOLON       reduce using rule 70 (_expression -> EQUAL_TO numexpression .)
    RPAREN          reduce using rule 70 (_expression -> EQUAL_TO numexpression .)


state 139

    (71) _expression -> NOT_EQUAL_TO numexpression .

    SEMICOLON       reduce using rule 71 (_expression -> NOT_EQUAL_TO numexpression .)
    RPAREN          reduce using rule 71 (_expression -> NOT_EQUAL_TO numexpression .)


state 140

    (74) numexpression_line -> PLUS term . numexpression_line
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 166
    empty                          shift and go to state 104

state 141

    (75) numexpression_line -> MINUS term . numexpression_line
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 167
    empty                          shift and go to state 104

state 142

    (78) term_line -> TIMES unaryexpr . term_line
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 168
    empty                          shift and go to state 109

state 143

    (79) term_line -> DIVIDE unaryexpr . term_line
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 169
    empty                          shift and go to state 109

state 144

    (80) term_line -> MODULO unaryexpr . term_line
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RBRACKET        reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 170
    empty                          shift and go to state 109

state 145

    (90) factor -> LPAREN numexpression RPAREN .

    TIMES           reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    DIVIDE          reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    MODULO          reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    PLUS            reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    MINUS           reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    LESS_THAN       reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    GREATER_THAN    reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    LESS_EQUAL_THAN reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    GREATER_EQUAL_THAN reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    EQUAL_TO        reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    NOT_EQUAL_TO    reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    SEMICOLON       reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    RBRACKET        reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)
    RPAREN          reduce using rule 90 (factor -> LPAREN numexpression RPAREN .)


state 146

    (51) ifstat -> IF make_scope LPAREN make_expression_goto . RPAREN LBRACES statelist RBRACES close_scope _ifstat

    RPAREN          shift and go to state 171


state 147

    (101) make_expression_goto -> expression .

    RPAREN          reduce using rule 101 (make_expression_goto -> expression .)
    SEMICOLON       reduce using rule 101 (make_expression_goto -> expression .)


state 148

    (54) forstat -> FOR make_loop_scope LPAREN atribstat . SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope

    SEMICOLON       shift and go to state 172


state 149

    (7) funcdef -> DEFINE IDENT make_scope LPAREN . paramlist RPAREN LBRACES statelist RBRACES close_scope
    (8) paramlist -> . INT IDENT _paramlist
    (9) paramlist -> . FLOAT IDENT _paramlist
    (10) paramlist -> . STRING IDENT _paramlist
    (11) paramlist -> . empty
    (104) empty -> .

    INT             shift and go to state 174
    FLOAT           shift and go to state 175
    STRING          shift and go to state 176
    RPAREN          reduce using rule 104 (empty -> .)

    paramlist                      shift and go to state 173
    empty                          shift and go to state 177

state 150

    (27) vardecl_line -> LBRACKET INT_CONSTANT RBRACKET . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (104) empty -> .

    LBRACKET        shift and go to state 76
    SEMICOLON       reduce using rule 104 (empty -> .)

    vardecl_line                   shift and go to state 178
    empty                          shift and go to state 77

state 151

    (96) lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .

    ASSIGN          reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    TIMES           reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    DIVIDE          reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    MODULO          reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    PLUS            reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    MINUS           reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    LESS_THAN       reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    GREATER_THAN    reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    LESS_EQUAL_THAN reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    GREATER_EQUAL_THAN reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    EQUAL_TO        reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    NOT_EQUAL_TO    reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    SEMICOLON       reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    RBRACKET        reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    RPAREN          reduce using rule 96 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)


state 152

    (35) _atribstat_help -> IDENT lvalue_line . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 179
    empty                          shift and go to state 109

state 153

    (42) ___atribstat -> lvalue_line term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 180
    empty                          shift and go to state 104

state 154

    (43) ___atribstat -> LPAREN paramlistcall . RPAREN

    RPAREN          shift and go to state 181


state 155

    (44) paramlistcall -> IDENT . _paramlistcall
    (46) _paramlistcall -> . COMMA paramlistcall
    (47) _paramlistcall -> . empty
    (104) empty -> .

    COMMA           shift and go to state 183
    RPAREN          reduce using rule 104 (empty -> .)

    _paramlistcall                 shift and go to state 182
    empty                          shift and go to state 184

state 156

    (45) paramlistcall -> empty .

    RPAREN          reduce using rule 45 (paramlistcall -> empty .)


state 157

    (37) __atribstat -> _node_int_constant term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 185
    empty                          shift and go to state 100

state 158

    (38) __atribstat -> _node_float_constant term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 186
    empty                          shift and go to state 100

state 159

    (39) __atribstat -> _node_str_constant term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 187
    empty                          shift and go to state 100

state 160

    (40) __atribstat -> _node_null_constant term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 188
    empty                          shift and go to state 100

state 161

    (41) __atribstat -> LPAREN numexpression RPAREN . term_line numexpression_line _expression
    (78) term_line -> . TIMES unaryexpr term_line
    (79) term_line -> . DIVIDE unaryexpr term_line
    (80) term_line -> . MODULO unaryexpr term_line
    (81) term_line -> . empty
    (104) empty -> .

    TIMES           shift and go to state 106
    DIVIDE          shift and go to state 107
    MODULO          shift and go to state 108
    PLUS            reduce using rule 104 (empty -> .)
    MINUS           reduce using rule 104 (empty -> .)
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    term_line                      shift and go to state 189
    empty                          shift and go to state 109

state 162

    (59) _allocexpression -> INT allocexpression_line .

    SEMICOLON       reduce using rule 59 (_allocexpression -> INT allocexpression_line .)
    RPAREN          reduce using rule 59 (_allocexpression -> INT allocexpression_line .)


state 163

    (62) allocexpression_line -> LBRACKET . numexpression RBRACKET _allocexpression_line
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    numexpression                  shift and go to state 190
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 164

    (60) _allocexpression -> FLOAT allocexpression_line .

    SEMICOLON       reduce using rule 60 (_allocexpression -> FLOAT allocexpression_line .)
    RPAREN          reduce using rule 60 (_allocexpression -> FLOAT allocexpression_line .)


state 165

    (61) _allocexpression -> STRING allocexpression_line .

    SEMICOLON       reduce using rule 61 (_allocexpression -> STRING allocexpression_line .)
    RPAREN          reduce using rule 61 (_allocexpression -> STRING allocexpression_line .)


state 166

    (74) numexpression_line -> PLUS term numexpression_line .

    LESS_THAN       reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    GREATER_THAN    reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    LESS_EQUAL_THAN reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    GREATER_EQUAL_THAN reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    EQUAL_TO        reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    NOT_EQUAL_TO    reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    SEMICOLON       reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    RBRACKET        reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)
    RPAREN          reduce using rule 74 (numexpression_line -> PLUS term numexpression_line .)


state 167

    (75) numexpression_line -> MINUS term numexpression_line .

    LESS_THAN       reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    GREATER_THAN    reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    LESS_EQUAL_THAN reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    GREATER_EQUAL_THAN reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    EQUAL_TO        reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    NOT_EQUAL_TO    reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    SEMICOLON       reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    RBRACKET        reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)
    RPAREN          reduce using rule 75 (numexpression_line -> MINUS term numexpression_line .)


state 168

    (78) term_line -> TIMES unaryexpr term_line .

    PLUS            reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    MINUS           reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    LESS_THAN       reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    GREATER_THAN    reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    LESS_EQUAL_THAN reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    GREATER_EQUAL_THAN reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    EQUAL_TO        reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    NOT_EQUAL_TO    reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    SEMICOLON       reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    RBRACKET        reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)
    RPAREN          reduce using rule 78 (term_line -> TIMES unaryexpr term_line .)


state 169

    (79) term_line -> DIVIDE unaryexpr term_line .

    PLUS            reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    MINUS           reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    LESS_THAN       reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    GREATER_THAN    reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    LESS_EQUAL_THAN reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    GREATER_EQUAL_THAN reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    EQUAL_TO        reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    NOT_EQUAL_TO    reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    SEMICOLON       reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    RBRACKET        reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)
    RPAREN          reduce using rule 79 (term_line -> DIVIDE unaryexpr term_line .)


state 170

    (80) term_line -> MODULO unaryexpr term_line .

    PLUS            reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    MINUS           reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    LESS_THAN       reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    GREATER_THAN    reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    LESS_EQUAL_THAN reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    GREATER_EQUAL_THAN reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    EQUAL_TO        reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    NOT_EQUAL_TO    reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    SEMICOLON       reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    RBRACKET        reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)
    RPAREN          reduce using rule 80 (term_line -> MODULO unaryexpr term_line .)


state 171

    (51) ifstat -> IF make_scope LPAREN make_expression_goto RPAREN . LBRACES statelist RBRACES close_scope _ifstat

    LBRACES         shift and go to state 191


state 172

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON . make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (100) make_loop_label -> .

    PLUS            reduce using rule 100 (make_loop_label -> .)
    MINUS           reduce using rule 100 (make_loop_label -> .)
    LPAREN          reduce using rule 100 (make_loop_label -> .)
    INT_CONSTANT    reduce using rule 100 (make_loop_label -> .)
    FLOAT_CONSTANT  reduce using rule 100 (make_loop_label -> .)
    STRING_CONSTANT reduce using rule 100 (make_loop_label -> .)
    NULL            reduce using rule 100 (make_loop_label -> .)
    IDENT           reduce using rule 100 (make_loop_label -> .)

    make_loop_label                shift and go to state 192

state 173

    (7) funcdef -> DEFINE IDENT make_scope LPAREN paramlist . RPAREN LBRACES statelist RBRACES close_scope

    RPAREN          shift and go to state 193


state 174

    (8) paramlist -> INT . IDENT _paramlist

    IDENT           shift and go to state 194


state 175

    (9) paramlist -> FLOAT . IDENT _paramlist

    IDENT           shift and go to state 195


state 176

    (10) paramlist -> STRING . IDENT _paramlist

    IDENT           shift and go to state 196


state 177

    (11) paramlist -> empty .

    RPAREN          reduce using rule 11 (paramlist -> empty .)


state 178

    (27) vardecl_line -> LBRACKET INT_CONSTANT RBRACKET vardecl_line .

    SEMICOLON       reduce using rule 27 (vardecl_line -> LBRACKET INT_CONSTANT RBRACKET vardecl_line .)


state 179

    (35) _atribstat_help -> IDENT lvalue_line term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 197
    empty                          shift and go to state 104

state 180

    (42) ___atribstat -> lvalue_line term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 198
    empty                          shift and go to state 100

state 181

    (43) ___atribstat -> LPAREN paramlistcall RPAREN .

    SEMICOLON       reduce using rule 43 (___atribstat -> LPAREN paramlistcall RPAREN .)
    RPAREN          reduce using rule 43 (___atribstat -> LPAREN paramlistcall RPAREN .)


state 182

    (44) paramlistcall -> IDENT _paramlistcall .

    RPAREN          reduce using rule 44 (paramlistcall -> IDENT _paramlistcall .)


state 183

    (46) _paramlistcall -> COMMA . paramlistcall
    (44) paramlistcall -> . IDENT _paramlistcall
    (45) paramlistcall -> . empty
    (104) empty -> .

    IDENT           shift and go to state 155
    RPAREN          reduce using rule 104 (empty -> .)

    paramlistcall                  shift and go to state 199
    empty                          shift and go to state 156

state 184

    (47) _paramlistcall -> empty .

    RPAREN          reduce using rule 47 (_paramlistcall -> empty .)


state 185

    (37) __atribstat -> _node_int_constant term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 37 (__atribstat -> _node_int_constant term_line numexpression_line _expression .)
    RPAREN          reduce using rule 37 (__atribstat -> _node_int_constant term_line numexpression_line _expression .)


state 186

    (38) __atribstat -> _node_float_constant term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 38 (__atribstat -> _node_float_constant term_line numexpression_line _expression .)
    RPAREN          reduce using rule 38 (__atribstat -> _node_float_constant term_line numexpression_line _expression .)


state 187

    (39) __atribstat -> _node_str_constant term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 39 (__atribstat -> _node_str_constant term_line numexpression_line _expression .)
    RPAREN          reduce using rule 39 (__atribstat -> _node_str_constant term_line numexpression_line _expression .)


state 188

    (40) __atribstat -> _node_null_constant term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 40 (__atribstat -> _node_null_constant term_line numexpression_line _expression .)
    RPAREN          reduce using rule 40 (__atribstat -> _node_null_constant term_line numexpression_line _expression .)


state 189

    (41) __atribstat -> LPAREN numexpression RPAREN term_line . numexpression_line _expression
    (74) numexpression_line -> . PLUS term numexpression_line
    (75) numexpression_line -> . MINUS term numexpression_line
    (76) numexpression_line -> . empty
    (104) empty -> .

    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    LESS_THAN       reduce using rule 104 (empty -> .)
    GREATER_THAN    reduce using rule 104 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 104 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 104 (empty -> .)
    EQUAL_TO        reduce using rule 104 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    numexpression_line             shift and go to state 200
    empty                          shift and go to state 104

state 190

    (62) allocexpression_line -> LBRACKET numexpression . RBRACKET _allocexpression_line

    RBRACKET        shift and go to state 201


state 191

    (51) ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES . statelist RBRACES close_scope _ifstat
    (55) statelist -> . statement _statelist
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (95) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    IDENT           shift and go to state 18

    statelist                      shift and go to state 202
    statement                      shift and go to state 37
    vardecl                        shift and go to state 6
    atribstat                      shift and go to state 8
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    lvalue                         shift and go to state 21

state 192

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label . make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (101) make_expression_goto -> . expression
    (65) expression -> . numexpression _expression
    (73) numexpression -> . term numexpression_line
    (77) term -> . unaryexpr term_line
    (82) unaryexpr -> . factor
    (83) unaryexpr -> . PLUS factor
    (84) unaryexpr -> . MINUS factor
    (85) factor -> . _node_int_constant
    (86) factor -> . _node_float_constant
    (87) factor -> . _node_str_constant
    (88) factor -> . _node_null_constant
    (89) factor -> . lvalue
    (90) factor -> . LPAREN numexpression RPAREN
    (91) _node_int_constant -> . INT_CONSTANT
    (92) _node_float_constant -> . FLOAT_CONSTANT
    (93) _node_str_constant -> . STRING_CONSTANT
    (94) _node_null_constant -> . NULL
    (95) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 54
    MINUS           shift and go to state 55
    LPAREN          shift and go to state 61
    INT_CONSTANT    shift and go to state 62
    FLOAT_CONSTANT  shift and go to state 63
    STRING_CONSTANT shift and go to state 64
    NULL            shift and go to state 65
    IDENT           shift and go to state 18

    make_expression_goto           shift and go to state 203
    expression                     shift and go to state 147
    numexpression                  shift and go to state 50
    term                           shift and go to state 51
    unaryexpr                      shift and go to state 52
    factor                         shift and go to state 53
    _node_int_constant             shift and go to state 56
    _node_float_constant           shift and go to state 57
    _node_str_constant             shift and go to state 58
    _node_null_constant            shift and go to state 59
    lvalue                         shift and go to state 60

state 193

    (7) funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN . LBRACES statelist RBRACES close_scope

    LBRACES         shift and go to state 204


state 194

    (8) paramlist -> INT IDENT . _paramlist
    (12) _paramlist -> . COMMA paramlist
    (13) _paramlist -> . empty
    (104) empty -> .

    COMMA           shift and go to state 206
    RPAREN          reduce using rule 104 (empty -> .)

    _paramlist                     shift and go to state 205
    empty                          shift and go to state 207

state 195

    (9) paramlist -> FLOAT IDENT . _paramlist
    (12) _paramlist -> . COMMA paramlist
    (13) _paramlist -> . empty
    (104) empty -> .

    COMMA           shift and go to state 206
    RPAREN          reduce using rule 104 (empty -> .)

    _paramlist                     shift and go to state 208
    empty                          shift and go to state 207

state 196

    (10) paramlist -> STRING IDENT . _paramlist
    (12) _paramlist -> . COMMA paramlist
    (13) _paramlist -> . empty
    (104) empty -> .

    COMMA           shift and go to state 206
    RPAREN          reduce using rule 104 (empty -> .)

    _paramlist                     shift and go to state 209
    empty                          shift and go to state 207

state 197

    (35) _atribstat_help -> IDENT lvalue_line term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 210
    empty                          shift and go to state 100

state 198

    (42) ___atribstat -> lvalue_line term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 42 (___atribstat -> lvalue_line term_line numexpression_line _expression .)
    RPAREN          reduce using rule 42 (___atribstat -> lvalue_line term_line numexpression_line _expression .)


state 199

    (46) _paramlistcall -> COMMA paramlistcall .

    RPAREN          reduce using rule 46 (_paramlistcall -> COMMA paramlistcall .)


state 200

    (41) __atribstat -> LPAREN numexpression RPAREN term_line numexpression_line . _expression
    (66) _expression -> . LESS_THAN numexpression
    (67) _expression -> . GREATER_THAN numexpression
    (68) _expression -> . LESS_EQUAL_THAN numexpression
    (69) _expression -> . GREATER_EQUAL_THAN numexpression
    (70) _expression -> . EQUAL_TO numexpression
    (71) _expression -> . NOT_EQUAL_TO numexpression
    (72) _expression -> . empty
    (104) empty -> .

    LESS_THAN       shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_EQUAL_THAN shift and go to state 96
    GREATER_EQUAL_THAN shift and go to state 97
    EQUAL_TO        shift and go to state 98
    NOT_EQUAL_TO    shift and go to state 99
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _expression                    shift and go to state 211
    empty                          shift and go to state 100

state 201

    (62) allocexpression_line -> LBRACKET numexpression RBRACKET . _allocexpression_line
    (63) _allocexpression_line -> . allocexpression_line
    (64) _allocexpression_line -> . empty
    (62) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line
    (104) empty -> .

    LBRACKET        shift and go to state 163
    SEMICOLON       reduce using rule 104 (empty -> .)
    RPAREN          reduce using rule 104 (empty -> .)

    _allocexpression_line          shift and go to state 212
    allocexpression_line           shift and go to state 213
    empty                          shift and go to state 214

state 202

    (51) ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist . RBRACES close_scope _ifstat

    RBRACES         shift and go to state 215


state 203

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto . SEMICOLON atribstat RPAREN statement close_scope

    SEMICOLON       shift and go to state 216


state 204

    (7) funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES . statelist RBRACES close_scope
    (55) statelist -> . statement _statelist
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (95) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    IDENT           shift and go to state 18

    statelist                      shift and go to state 217
    statement                      shift and go to state 37
    vardecl                        shift and go to state 6
    atribstat                      shift and go to state 8
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    lvalue                         shift and go to state 21

state 205

    (8) paramlist -> INT IDENT _paramlist .

    RPAREN          reduce using rule 8 (paramlist -> INT IDENT _paramlist .)


state 206

    (12) _paramlist -> COMMA . paramlist
    (8) paramlist -> . INT IDENT _paramlist
    (9) paramlist -> . FLOAT IDENT _paramlist
    (10) paramlist -> . STRING IDENT _paramlist
    (11) paramlist -> . empty
    (104) empty -> .

    INT             shift and go to state 174
    FLOAT           shift and go to state 175
    STRING          shift and go to state 176
    RPAREN          reduce using rule 104 (empty -> .)

    paramlist                      shift and go to state 218
    empty                          shift and go to state 177

state 207

    (13) _paramlist -> empty .

    RPAREN          reduce using rule 13 (_paramlist -> empty .)


state 208

    (9) paramlist -> FLOAT IDENT _paramlist .

    RPAREN          reduce using rule 9 (paramlist -> FLOAT IDENT _paramlist .)


state 209

    (10) paramlist -> STRING IDENT _paramlist .

    RPAREN          reduce using rule 10 (paramlist -> STRING IDENT _paramlist .)


state 210

    (35) _atribstat_help -> IDENT lvalue_line term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 35 (_atribstat_help -> IDENT lvalue_line term_line numexpression_line _expression .)
    RPAREN          reduce using rule 35 (_atribstat_help -> IDENT lvalue_line term_line numexpression_line _expression .)


state 211

    (41) __atribstat -> LPAREN numexpression RPAREN term_line numexpression_line _expression .

    SEMICOLON       reduce using rule 41 (__atribstat -> LPAREN numexpression RPAREN term_line numexpression_line _expression .)
    RPAREN          reduce using rule 41 (__atribstat -> LPAREN numexpression RPAREN term_line numexpression_line _expression .)


state 212

    (62) allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line .

    SEMICOLON       reduce using rule 62 (allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line .)
    RPAREN          reduce using rule 62 (allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line .)


state 213

    (63) _allocexpression_line -> allocexpression_line .

    SEMICOLON       reduce using rule 63 (_allocexpression_line -> allocexpression_line .)
    RPAREN          reduce using rule 63 (_allocexpression_line -> allocexpression_line .)


state 214

    (64) _allocexpression_line -> empty .

    SEMICOLON       reduce using rule 64 (_allocexpression_line -> empty .)
    RPAREN          reduce using rule 64 (_allocexpression_line -> empty .)


state 215

    (51) ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES . close_scope _ifstat
    (103) close_scope -> .

    ELSE            reduce using rule 103 (close_scope -> .)
    $end            reduce using rule 103 (close_scope -> .)
    LBRACES         reduce using rule 103 (close_scope -> .)
    SEMICOLON       reduce using rule 103 (close_scope -> .)
    INT             reduce using rule 103 (close_scope -> .)
    FLOAT           reduce using rule 103 (close_scope -> .)
    STRING          reduce using rule 103 (close_scope -> .)
    PRINT           reduce using rule 103 (close_scope -> .)
    READ            reduce using rule 103 (close_scope -> .)
    RETURN          reduce using rule 103 (close_scope -> .)
    IF              reduce using rule 103 (close_scope -> .)
    FOR             reduce using rule 103 (close_scope -> .)
    IDENT           reduce using rule 103 (close_scope -> .)
    BREAK           reduce using rule 103 (close_scope -> .)
    RBRACES         reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 219

state 216

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON . atribstat RPAREN statement close_scope
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (95) lvalue -> . IDENT lvalue_line

    IDENT           shift and go to state 18

    atribstat                      shift and go to state 220
    lvalue                         shift and go to state 21

state 217

    (7) funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist . RBRACES close_scope

    RBRACES         shift and go to state 221


state 218

    (12) _paramlist -> COMMA paramlist .

    RPAREN          reduce using rule 12 (_paramlist -> COMMA paramlist .)


state 219

    (51) ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope . _ifstat
    (52) _ifstat -> . make_scope ELSE statement close_scope
    (53) _ifstat -> . empty
    (98) make_scope -> .
    (104) empty -> .

    ELSE            reduce using rule 98 (make_scope -> .)
    $end            reduce using rule 104 (empty -> .)
    LBRACES         reduce using rule 104 (empty -> .)
    SEMICOLON       reduce using rule 104 (empty -> .)
    INT             reduce using rule 104 (empty -> .)
    FLOAT           reduce using rule 104 (empty -> .)
    STRING          reduce using rule 104 (empty -> .)
    PRINT           reduce using rule 104 (empty -> .)
    READ            reduce using rule 104 (empty -> .)
    RETURN          reduce using rule 104 (empty -> .)
    IF              reduce using rule 104 (empty -> .)
    FOR             reduce using rule 104 (empty -> .)
    IDENT           reduce using rule 104 (empty -> .)
    BREAK           reduce using rule 104 (empty -> .)
    RBRACES         reduce using rule 104 (empty -> .)

    make_scope                     shift and go to state 222
    _ifstat                        shift and go to state 223
    empty                          shift and go to state 224

state 220

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat . RPAREN statement close_scope

    RPAREN          shift and go to state 225


state 221

    (7) funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES . close_scope
    (103) close_scope -> .

    DEFINE          reduce using rule 103 (close_scope -> .)
    $end            reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 226

state 222

    (52) _ifstat -> make_scope . ELSE statement close_scope

    ELSE            shift and go to state 227


state 223

    (51) ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .

    $end            reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    LBRACES         reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    SEMICOLON       reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    INT             reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    FLOAT           reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    STRING          reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    PRINT           reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    READ            reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    RETURN          reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    IF              reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    FOR             reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    IDENT           reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    BREAK           reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)
    RBRACES         reduce using rule 51 (ifstat -> IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat .)


state 224

    (53) _ifstat -> empty .

    $end            reduce using rule 53 (_ifstat -> empty .)
    LBRACES         reduce using rule 53 (_ifstat -> empty .)
    SEMICOLON       reduce using rule 53 (_ifstat -> empty .)
    INT             reduce using rule 53 (_ifstat -> empty .)
    FLOAT           reduce using rule 53 (_ifstat -> empty .)
    STRING          reduce using rule 53 (_ifstat -> empty .)
    PRINT           reduce using rule 53 (_ifstat -> empty .)
    READ            reduce using rule 53 (_ifstat -> empty .)
    RETURN          reduce using rule 53 (_ifstat -> empty .)
    IF              reduce using rule 53 (_ifstat -> empty .)
    FOR             reduce using rule 53 (_ifstat -> empty .)
    IDENT           reduce using rule 53 (_ifstat -> empty .)
    BREAK           reduce using rule 53 (_ifstat -> empty .)
    RBRACES         reduce using rule 53 (_ifstat -> empty .)


state 225

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN . statement close_scope
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (95) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    IDENT           shift and go to state 18

    atribstat                      shift and go to state 8
    statement                      shift and go to state 228
    vardecl                        shift and go to state 6
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    lvalue                         shift and go to state 21

state 226

    (7) funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope .

    DEFINE          reduce using rule 7 (funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope .)
    $end            reduce using rule 7 (funcdef -> DEFINE IDENT make_scope LPAREN paramlist RPAREN LBRACES statelist RBRACES close_scope .)


state 227

    (52) _ifstat -> make_scope ELSE . statement close_scope
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . check_loop_scope BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (48) printstat -> . PRINT expression
    (49) readstat -> . READ lvalue
    (50) returnstat -> . RETURN
    (51) ifstat -> . IF make_scope LPAREN make_expression_goto RPAREN LBRACES statelist RBRACES close_scope _ifstat
    (54) forstat -> . FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope
    (102) check_loop_scope -> .
    (95) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 14
    SEMICOLON       shift and go to state 7
    INT             shift and go to state 17
    FLOAT           shift and go to state 19
    STRING          shift and go to state 20
    PRINT           shift and go to state 22
    READ            shift and go to state 23
    RETURN          shift and go to state 24
    IF              shift and go to state 25
    FOR             shift and go to state 26
    BREAK           reduce using rule 102 (check_loop_scope -> .)
    IDENT           shift and go to state 18

    statement                      shift and go to state 229
    vardecl                        shift and go to state 6
    atribstat                      shift and go to state 8
    printstat                      shift and go to state 9
    readstat                       shift and go to state 10
    returnstat                     shift and go to state 11
    ifstat                         shift and go to state 12
    forstat                        shift and go to state 13
    check_loop_scope               shift and go to state 15
    lvalue                         shift and go to state 21

state 228

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement . close_scope
    (103) close_scope -> .

    $end            reduce using rule 103 (close_scope -> .)
    LBRACES         reduce using rule 103 (close_scope -> .)
    SEMICOLON       reduce using rule 103 (close_scope -> .)
    INT             reduce using rule 103 (close_scope -> .)
    FLOAT           reduce using rule 103 (close_scope -> .)
    STRING          reduce using rule 103 (close_scope -> .)
    PRINT           reduce using rule 103 (close_scope -> .)
    READ            reduce using rule 103 (close_scope -> .)
    RETURN          reduce using rule 103 (close_scope -> .)
    IF              reduce using rule 103 (close_scope -> .)
    FOR             reduce using rule 103 (close_scope -> .)
    IDENT           reduce using rule 103 (close_scope -> .)
    BREAK           reduce using rule 103 (close_scope -> .)
    RBRACES         reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 230

state 229

    (52) _ifstat -> make_scope ELSE statement . close_scope
    (103) close_scope -> .

    $end            reduce using rule 103 (close_scope -> .)
    LBRACES         reduce using rule 103 (close_scope -> .)
    SEMICOLON       reduce using rule 103 (close_scope -> .)
    INT             reduce using rule 103 (close_scope -> .)
    FLOAT           reduce using rule 103 (close_scope -> .)
    STRING          reduce using rule 103 (close_scope -> .)
    PRINT           reduce using rule 103 (close_scope -> .)
    READ            reduce using rule 103 (close_scope -> .)
    RETURN          reduce using rule 103 (close_scope -> .)
    IF              reduce using rule 103 (close_scope -> .)
    FOR             reduce using rule 103 (close_scope -> .)
    IDENT           reduce using rule 103 (close_scope -> .)
    BREAK           reduce using rule 103 (close_scope -> .)
    RBRACES         reduce using rule 103 (close_scope -> .)

    close_scope                    shift and go to state 231

state 230

    (54) forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .

    $end            reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    LBRACES         reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    SEMICOLON       reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    INT             reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    FLOAT           reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    STRING          reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    PRINT           reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    READ            reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    RETURN          reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    IF              reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    FOR             reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    IDENT           reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    BREAK           reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)
    RBRACES         reduce using rule 54 (forstat -> FOR make_loop_scope LPAREN atribstat SEMICOLON make_loop_label make_expression_goto SEMICOLON atribstat RPAREN statement close_scope .)


state 231

    (52) _ifstat -> make_scope ELSE statement close_scope .

    $end            reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    LBRACES         reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    SEMICOLON       reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    INT             reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    FLOAT           reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    STRING          reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    PRINT           reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    READ            reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    RETURN          reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    IF              reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    FOR             reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    IDENT           reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    BREAK           reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)
    RBRACES         reduce using rule 52 (_ifstat -> make_scope ELSE statement close_scope .)

