Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> funclist
Rule 3     program -> empty
Rule 4     funclist -> funcdef _funclist
Rule 5     _funclist -> funclist
Rule 6     _funclist -> empty
Rule 7     funcdef -> DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES
Rule 8     paramlist -> INT IDENT _paramlist
Rule 9     paramlist -> FLOAT IDENT _paramlist
Rule 10    paramlist -> STRING IDENT _paramlist
Rule 11    paramlist -> empty
Rule 12    _paramlist -> COMMA paramlist
Rule 13    _paramlist -> empty
Rule 14    statement -> vardecl SEMICOLON
Rule 15    statement -> atribstat SEMICOLON
Rule 16    statement -> printstat SEMICOLON
Rule 17    statement -> readstat SEMICOLON
Rule 18    statement -> returnstat SEMICOLON
Rule 19    statement -> ifstat
Rule 20    statement -> forstat
Rule 21    statement -> LBRACES statelist RBRACES
Rule 22    statement -> BREAK SEMICOLON
Rule 23    statement -> SEMICOLON
Rule 24    vardecl -> INT IDENT vardecl_line
Rule 25    vardecl -> FLOAT IDENT vardecl_line
Rule 26    vardecl -> STRING IDENT vardecl_line
Rule 27    vardecl_line -> LBRACKET INT_CONSTANT RBRACKET vardecl_line
Rule 28    vardecl_line -> empty
Rule 29    atribstat -> lvalue ASSIGN _atribstat
Rule 30    _atribstat -> INT_CONSTANT term_line _expression
Rule 31    _atribstat -> FLOAT_CONSTANT term_line _expression
Rule 32    _atribstat -> STRING_CONSTANT term_line _expression
Rule 33    _atribstat -> NULL term_line _expression
Rule 34    _atribstat -> IDENT __atribstat
Rule 35    _atribstat -> LPAREN numexpression RPAREN term_line _expression
Rule 36    _atribstat -> PLUS _numexpression _expression
Rule 37    _atribstat -> MINUS _numexpression _expression
Rule 38    _atribstat -> _expression
Rule 39    _atribstat -> allocexpression
Rule 40    __atribstat -> lvalue_line term_line _expression
Rule 41    __atribstat -> LPAREN paramlistcall RPAREN
Rule 42    funccall -> IDENT LPAREN paramlistcall RPAREN
Rule 43    paramlistcall -> IDENT _paramlistcall
Rule 44    paramlistcall -> empty
Rule 45    _paramlistcall -> COMMA paramlistcall
Rule 46    _paramlistcall -> empty
Rule 47    printstat -> PRINT expression
Rule 48    readstat -> READ lvalue
Rule 49    returnstat -> RETURN
Rule 50    ifstat -> IF LPAREN expression RPAREN statement _ifstat
Rule 51    _ifstat -> ELSE statement
Rule 52    _ifstat -> empty
Rule 53    forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
Rule 54    statelist -> statement _statelist
Rule 55    _statelist -> statelist
Rule 56    _statelist -> empty
Rule 57    allocexpression -> NEW _allocexpression
Rule 58    _allocexpression -> INT allocexpression_line
Rule 59    _allocexpression -> FLOAT allocexpression_line
Rule 60    _allocexpression -> STRING allocexpression_line
Rule 61    allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line
Rule 62    _allocexpression_line -> allocexpression_line
Rule 63    _allocexpression_line -> empty
Rule 64    expression -> numexpression _expression
Rule 65    _expression -> LESS_THAN numexpression
Rule 66    _expression -> GREATER_THAN numexpression
Rule 67    _expression -> LESS_EQUAL_THAN numexpression
Rule 68    _expression -> GREATER_EQUAL_THAN numexpression
Rule 69    _expression -> EQUAL_TO numexpression
Rule 70    _expression -> NOT_EQUAL_TO numexpression
Rule 71    numexpression -> factor term_line
Rule 72    numexpression -> PLUS _numexpression
Rule 73    numexpression -> MINUS _numexpression
Rule 74    numexpression -> empty
Rule 75    _numexpression -> factor term_line
Rule 76    _numexpression -> term numexpression_line
Rule 77    numexpression_line -> PLUS term numexpression_line
Rule 78    numexpression_line -> MINUS term numexpression_line
Rule 79    numexpression_line -> empty
Rule 80    term -> unaryexpre term_line
Rule 81    term_line -> TIMES unaryexpre term_line
Rule 82    term_line -> DIVIDE unaryexpre term_line
Rule 83    term_line -> MODULO unaryexpre term_line
Rule 84    term_line -> empty
Rule 85    unaryexpre -> factor
Rule 86    unaryexpre -> PLUS factor
Rule 87    unaryexpre -> MINUS factor
Rule 88    factor -> INT_CONSTANT
Rule 89    factor -> FLOAT_CONSTANT
Rule 90    factor -> STRING_CONSTANT
Rule 91    factor -> NULL
Rule 92    factor -> lvalue
Rule 93    factor -> LPAREN numexpression RPAREN
Rule 94    lvalue -> IDENT lvalue_line
Rule 95    lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line
Rule 96    lvalue_line -> empty
Rule 97    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 29
BREAK                : 22
COMMA                : 12 45
COMMENT              : 
DEFINE               : 7
DIVIDE               : 82
ELSE                 : 51
EQUAL_TO             : 69
FLOAT                : 9 25 59
FLOAT_CONSTANT       : 31 89
FOR                  : 53
GREATER_EQUAL_THAN   : 68
GREATER_THAN         : 66
IDENT                : 7 8 9 10 24 25 26 34 42 43 94
IF                   : 50
INT                  : 8 24 58
INT_CONSTANT         : 27 30 88
LBRACES              : 7 21
LBRACKET             : 27 61 95
LESS_EQUAL_THAN      : 67
LESS_THAN            : 65
LPAREN               : 7 35 41 42 50 53 93
MINUS                : 37 73 78 87
MODULO               : 83
NEW                  : 57
NOT_EQUAL_TO         : 70
NULL                 : 33 91
PLUS                 : 36 72 77 86
PRINT                : 47
RBRACES              : 7 21
RBRACKET             : 27 61 95
READ                 : 48
RETURN               : 49
RPAREN               : 7 35 41 42 50 53 93
SEMICOLON            : 14 15 16 17 18 22 23 53 53
STRING               : 10 26 60
STRING_CONSTANT      : 32 90
TIMES                : 81
error                : 

Nonterminals, with rules where they appear

__atribstat          : 34
_allocexpression     : 57
_allocexpression_line : 61
_atribstat           : 29
_expression          : 30 31 32 33 35 36 37 38 40 64
_funclist            : 4
_ifstat              : 50
_numexpression       : 36 37 72 73
_paramlist           : 8 9 10
_paramlistcall       : 43
_statelist           : 54
allocexpression      : 39
allocexpression_line : 58 59 60 62
atribstat            : 15 53 53
empty                : 3 6 11 13 28 44 46 52 56 63 74 79 84 96
expression           : 47 50 53
factor               : 71 75 85 86 87
forstat              : 20
funccall             : 
funcdef              : 4
funclist             : 2 5
ifstat               : 19
lvalue               : 29 48 92
lvalue_line          : 40 94 95
numexpression        : 35 61 64 65 66 67 68 69 70 93 95
numexpression_line   : 76 77 78
paramlist            : 7 12
paramlistcall        : 41 42 45
printstat            : 16
program              : 0
readstat             : 17
returnstat           : 18
statelist            : 7 21 55
statement            : 1 50 51 53 54
term                 : 76 77 78
term_line            : 30 31 32 33 35 40 71 75 80 81 82 83
unaryexpre           : 80 81 82 83
vardecl              : 14
vardecl_line         : 24 25 26 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . funclist
    (3) program -> . empty
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (4) funclist -> . funcdef _funclist
    (97) empty -> .
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (7) funcdef -> . DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES
    (94) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    $end            reduce using rule 97 (empty -> .)
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    DEFINE          shift and go to state 26
    IDENT           shift and go to state 17

    program                        shift and go to state 1
    statement                      shift and go to state 2
    funclist                       shift and go to state 3
    empty                          shift and go to state 4
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    funcdef                        shift and go to state 15
    lvalue                         shift and go to state 20

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) program -> funclist .

    $end            reduce using rule 2 (program -> funclist .)


state 4

    (3) program -> empty .

    $end            reduce using rule 3 (program -> empty .)


state 5

    (14) statement -> vardecl . SEMICOLON

    SEMICOLON       shift and go to state 27


state 6

    (23) statement -> SEMICOLON .

    $end            reduce using rule 23 (statement -> SEMICOLON .)
    LBRACES         reduce using rule 23 (statement -> SEMICOLON .)
    BREAK           reduce using rule 23 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 23 (statement -> SEMICOLON .)
    INT             reduce using rule 23 (statement -> SEMICOLON .)
    FLOAT           reduce using rule 23 (statement -> SEMICOLON .)
    STRING          reduce using rule 23 (statement -> SEMICOLON .)
    PRINT           reduce using rule 23 (statement -> SEMICOLON .)
    READ            reduce using rule 23 (statement -> SEMICOLON .)
    RETURN          reduce using rule 23 (statement -> SEMICOLON .)
    IF              reduce using rule 23 (statement -> SEMICOLON .)
    FOR             reduce using rule 23 (statement -> SEMICOLON .)
    IDENT           reduce using rule 23 (statement -> SEMICOLON .)
    RBRACES         reduce using rule 23 (statement -> SEMICOLON .)
    ELSE            reduce using rule 23 (statement -> SEMICOLON .)


state 7

    (15) statement -> atribstat . SEMICOLON

    SEMICOLON       shift and go to state 28


state 8

    (16) statement -> printstat . SEMICOLON

    SEMICOLON       shift and go to state 29


state 9

    (17) statement -> readstat . SEMICOLON

    SEMICOLON       shift and go to state 30


state 10

    (18) statement -> returnstat . SEMICOLON

    SEMICOLON       shift and go to state 31


state 11

    (19) statement -> ifstat .

    $end            reduce using rule 19 (statement -> ifstat .)
    LBRACES         reduce using rule 19 (statement -> ifstat .)
    BREAK           reduce using rule 19 (statement -> ifstat .)
    SEMICOLON       reduce using rule 19 (statement -> ifstat .)
    INT             reduce using rule 19 (statement -> ifstat .)
    FLOAT           reduce using rule 19 (statement -> ifstat .)
    STRING          reduce using rule 19 (statement -> ifstat .)
    PRINT           reduce using rule 19 (statement -> ifstat .)
    READ            reduce using rule 19 (statement -> ifstat .)
    RETURN          reduce using rule 19 (statement -> ifstat .)
    IF              reduce using rule 19 (statement -> ifstat .)
    FOR             reduce using rule 19 (statement -> ifstat .)
    IDENT           reduce using rule 19 (statement -> ifstat .)
    RBRACES         reduce using rule 19 (statement -> ifstat .)
    ELSE            reduce using rule 19 (statement -> ifstat .)


state 12

    (20) statement -> forstat .

    $end            reduce using rule 20 (statement -> forstat .)
    LBRACES         reduce using rule 20 (statement -> forstat .)
    BREAK           reduce using rule 20 (statement -> forstat .)
    SEMICOLON       reduce using rule 20 (statement -> forstat .)
    INT             reduce using rule 20 (statement -> forstat .)
    FLOAT           reduce using rule 20 (statement -> forstat .)
    STRING          reduce using rule 20 (statement -> forstat .)
    PRINT           reduce using rule 20 (statement -> forstat .)
    READ            reduce using rule 20 (statement -> forstat .)
    RETURN          reduce using rule 20 (statement -> forstat .)
    IF              reduce using rule 20 (statement -> forstat .)
    FOR             reduce using rule 20 (statement -> forstat .)
    IDENT           reduce using rule 20 (statement -> forstat .)
    RBRACES         reduce using rule 20 (statement -> forstat .)
    ELSE            reduce using rule 20 (statement -> forstat .)


state 13

    (21) statement -> LBRACES . statelist RBRACES
    (54) statelist -> . statement _statelist
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (94) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    IDENT           shift and go to state 17

    statelist                      shift and go to state 32
    statement                      shift and go to state 33
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    lvalue                         shift and go to state 20

state 14

    (22) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 34


state 15

    (4) funclist -> funcdef . _funclist
    (5) _funclist -> . funclist
    (6) _funclist -> . empty
    (4) funclist -> . funcdef _funclist
    (97) empty -> .
    (7) funcdef -> . DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES

    $end            reduce using rule 97 (empty -> .)
    DEFINE          shift and go to state 26

    funcdef                        shift and go to state 15
    _funclist                      shift and go to state 35
    funclist                       shift and go to state 36
    empty                          shift and go to state 37

state 16

    (24) vardecl -> INT . IDENT vardecl_line

    IDENT           shift and go to state 38


state 17

    (94) lvalue -> IDENT . lvalue_line
    (95) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (96) lvalue_line -> . empty
    (97) empty -> .

    LBRACKET        shift and go to state 40
    ASSIGN          reduce using rule 97 (empty -> .)
    TIMES           reduce using rule 97 (empty -> .)
    DIVIDE          reduce using rule 97 (empty -> .)
    MODULO          reduce using rule 97 (empty -> .)
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    PLUS            reduce using rule 97 (empty -> .)
    MINUS           reduce using rule 97 (empty -> .)

    lvalue_line                    shift and go to state 39
    empty                          shift and go to state 41

state 18

    (25) vardecl -> FLOAT . IDENT vardecl_line

    IDENT           shift and go to state 42


state 19

    (26) vardecl -> STRING . IDENT vardecl_line

    IDENT           shift and go to state 43


state 20

    (29) atribstat -> lvalue . ASSIGN _atribstat

    ASSIGN          shift and go to state 44


state 21

    (47) printstat -> PRINT . expression
    (64) expression -> . numexpression _expression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    expression                     shift and go to state 45
    numexpression                  shift and go to state 46
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 22

    (48) readstat -> READ . lvalue
    (94) lvalue -> . IDENT lvalue_line

    IDENT           shift and go to state 17

    lvalue                         shift and go to state 57

state 23

    (49) returnstat -> RETURN .

    SEMICOLON       reduce using rule 49 (returnstat -> RETURN .)


state 24

    (50) ifstat -> IF . LPAREN expression RPAREN statement _ifstat

    LPAREN          shift and go to state 58


state 25

    (53) forstat -> FOR . LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement

    LPAREN          shift and go to state 59


state 26

    (7) funcdef -> DEFINE . IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES

    IDENT           shift and go to state 60


state 27

    (14) statement -> vardecl SEMICOLON .

    $end            reduce using rule 14 (statement -> vardecl SEMICOLON .)
    LBRACES         reduce using rule 14 (statement -> vardecl SEMICOLON .)
    BREAK           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    SEMICOLON       reduce using rule 14 (statement -> vardecl SEMICOLON .)
    INT             reduce using rule 14 (statement -> vardecl SEMICOLON .)
    FLOAT           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    STRING          reduce using rule 14 (statement -> vardecl SEMICOLON .)
    PRINT           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    READ            reduce using rule 14 (statement -> vardecl SEMICOLON .)
    RETURN          reduce using rule 14 (statement -> vardecl SEMICOLON .)
    IF              reduce using rule 14 (statement -> vardecl SEMICOLON .)
    FOR             reduce using rule 14 (statement -> vardecl SEMICOLON .)
    IDENT           reduce using rule 14 (statement -> vardecl SEMICOLON .)
    RBRACES         reduce using rule 14 (statement -> vardecl SEMICOLON .)
    ELSE            reduce using rule 14 (statement -> vardecl SEMICOLON .)


state 28

    (15) statement -> atribstat SEMICOLON .

    $end            reduce using rule 15 (statement -> atribstat SEMICOLON .)
    LBRACES         reduce using rule 15 (statement -> atribstat SEMICOLON .)
    BREAK           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    SEMICOLON       reduce using rule 15 (statement -> atribstat SEMICOLON .)
    INT             reduce using rule 15 (statement -> atribstat SEMICOLON .)
    FLOAT           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    STRING          reduce using rule 15 (statement -> atribstat SEMICOLON .)
    PRINT           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    READ            reduce using rule 15 (statement -> atribstat SEMICOLON .)
    RETURN          reduce using rule 15 (statement -> atribstat SEMICOLON .)
    IF              reduce using rule 15 (statement -> atribstat SEMICOLON .)
    FOR             reduce using rule 15 (statement -> atribstat SEMICOLON .)
    IDENT           reduce using rule 15 (statement -> atribstat SEMICOLON .)
    RBRACES         reduce using rule 15 (statement -> atribstat SEMICOLON .)
    ELSE            reduce using rule 15 (statement -> atribstat SEMICOLON .)


state 29

    (16) statement -> printstat SEMICOLON .

    $end            reduce using rule 16 (statement -> printstat SEMICOLON .)
    LBRACES         reduce using rule 16 (statement -> printstat SEMICOLON .)
    BREAK           reduce using rule 16 (statement -> printstat SEMICOLON .)
    SEMICOLON       reduce using rule 16 (statement -> printstat SEMICOLON .)
    INT             reduce using rule 16 (statement -> printstat SEMICOLON .)
    FLOAT           reduce using rule 16 (statement -> printstat SEMICOLON .)
    STRING          reduce using rule 16 (statement -> printstat SEMICOLON .)
    PRINT           reduce using rule 16 (statement -> printstat SEMICOLON .)
    READ            reduce using rule 16 (statement -> printstat SEMICOLON .)
    RETURN          reduce using rule 16 (statement -> printstat SEMICOLON .)
    IF              reduce using rule 16 (statement -> printstat SEMICOLON .)
    FOR             reduce using rule 16 (statement -> printstat SEMICOLON .)
    IDENT           reduce using rule 16 (statement -> printstat SEMICOLON .)
    RBRACES         reduce using rule 16 (statement -> printstat SEMICOLON .)
    ELSE            reduce using rule 16 (statement -> printstat SEMICOLON .)


state 30

    (17) statement -> readstat SEMICOLON .

    $end            reduce using rule 17 (statement -> readstat SEMICOLON .)
    LBRACES         reduce using rule 17 (statement -> readstat SEMICOLON .)
    BREAK           reduce using rule 17 (statement -> readstat SEMICOLON .)
    SEMICOLON       reduce using rule 17 (statement -> readstat SEMICOLON .)
    INT             reduce using rule 17 (statement -> readstat SEMICOLON .)
    FLOAT           reduce using rule 17 (statement -> readstat SEMICOLON .)
    STRING          reduce using rule 17 (statement -> readstat SEMICOLON .)
    PRINT           reduce using rule 17 (statement -> readstat SEMICOLON .)
    READ            reduce using rule 17 (statement -> readstat SEMICOLON .)
    RETURN          reduce using rule 17 (statement -> readstat SEMICOLON .)
    IF              reduce using rule 17 (statement -> readstat SEMICOLON .)
    FOR             reduce using rule 17 (statement -> readstat SEMICOLON .)
    IDENT           reduce using rule 17 (statement -> readstat SEMICOLON .)
    RBRACES         reduce using rule 17 (statement -> readstat SEMICOLON .)
    ELSE            reduce using rule 17 (statement -> readstat SEMICOLON .)


state 31

    (18) statement -> returnstat SEMICOLON .

    $end            reduce using rule 18 (statement -> returnstat SEMICOLON .)
    LBRACES         reduce using rule 18 (statement -> returnstat SEMICOLON .)
    BREAK           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    SEMICOLON       reduce using rule 18 (statement -> returnstat SEMICOLON .)
    INT             reduce using rule 18 (statement -> returnstat SEMICOLON .)
    FLOAT           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    STRING          reduce using rule 18 (statement -> returnstat SEMICOLON .)
    PRINT           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    READ            reduce using rule 18 (statement -> returnstat SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> returnstat SEMICOLON .)
    IF              reduce using rule 18 (statement -> returnstat SEMICOLON .)
    FOR             reduce using rule 18 (statement -> returnstat SEMICOLON .)
    IDENT           reduce using rule 18 (statement -> returnstat SEMICOLON .)
    RBRACES         reduce using rule 18 (statement -> returnstat SEMICOLON .)
    ELSE            reduce using rule 18 (statement -> returnstat SEMICOLON .)


state 32

    (21) statement -> LBRACES statelist . RBRACES

    RBRACES         shift and go to state 61


state 33

    (54) statelist -> statement . _statelist
    (55) _statelist -> . statelist
    (56) _statelist -> . empty
    (54) statelist -> . statement _statelist
    (97) empty -> .
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (94) lvalue -> . IDENT lvalue_line

    RBRACES         reduce using rule 97 (empty -> .)
    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    IDENT           shift and go to state 17

    statement                      shift and go to state 33
    _statelist                     shift and go to state 62
    statelist                      shift and go to state 63
    empty                          shift and go to state 64
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    lvalue                         shift and go to state 20

state 34

    (22) statement -> BREAK SEMICOLON .

    $end            reduce using rule 22 (statement -> BREAK SEMICOLON .)
    LBRACES         reduce using rule 22 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 22 (statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 22 (statement -> BREAK SEMICOLON .)
    INT             reduce using rule 22 (statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 22 (statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 22 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 22 (statement -> BREAK SEMICOLON .)
    READ            reduce using rule 22 (statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 22 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 22 (statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 22 (statement -> BREAK SEMICOLON .)
    IDENT           reduce using rule 22 (statement -> BREAK SEMICOLON .)
    RBRACES         reduce using rule 22 (statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 22 (statement -> BREAK SEMICOLON .)


state 35

    (4) funclist -> funcdef _funclist .

    $end            reduce using rule 4 (funclist -> funcdef _funclist .)


state 36

    (5) _funclist -> funclist .

    $end            reduce using rule 5 (_funclist -> funclist .)


state 37

    (6) _funclist -> empty .

    $end            reduce using rule 6 (_funclist -> empty .)


state 38

    (24) vardecl -> INT IDENT . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (97) empty -> .

    LBRACKET        shift and go to state 66
    SEMICOLON       reduce using rule 97 (empty -> .)

    vardecl_line                   shift and go to state 65
    empty                          shift and go to state 67

state 39

    (94) lvalue -> IDENT lvalue_line .

    ASSIGN          reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    TIMES           reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    DIVIDE          reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    MODULO          reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    LESS_THAN       reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    GREATER_THAN    reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    LESS_EQUAL_THAN reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    GREATER_EQUAL_THAN reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    EQUAL_TO        reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    NOT_EQUAL_TO    reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    SEMICOLON       reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    RBRACKET        reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    RPAREN          reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    PLUS            reduce using rule 94 (lvalue -> IDENT lvalue_line .)
    MINUS           reduce using rule 94 (lvalue -> IDENT lvalue_line .)


state 40

    (95) lvalue_line -> LBRACKET . numexpression RBRACKET lvalue_line
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    RBRACKET        reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 68
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 41

    (96) lvalue_line -> empty .

    ASSIGN          reduce using rule 96 (lvalue_line -> empty .)
    TIMES           reduce using rule 96 (lvalue_line -> empty .)
    DIVIDE          reduce using rule 96 (lvalue_line -> empty .)
    MODULO          reduce using rule 96 (lvalue_line -> empty .)
    LESS_THAN       reduce using rule 96 (lvalue_line -> empty .)
    GREATER_THAN    reduce using rule 96 (lvalue_line -> empty .)
    LESS_EQUAL_THAN reduce using rule 96 (lvalue_line -> empty .)
    GREATER_EQUAL_THAN reduce using rule 96 (lvalue_line -> empty .)
    EQUAL_TO        reduce using rule 96 (lvalue_line -> empty .)
    NOT_EQUAL_TO    reduce using rule 96 (lvalue_line -> empty .)
    SEMICOLON       reduce using rule 96 (lvalue_line -> empty .)
    RBRACKET        reduce using rule 96 (lvalue_line -> empty .)
    RPAREN          reduce using rule 96 (lvalue_line -> empty .)
    PLUS            reduce using rule 96 (lvalue_line -> empty .)
    MINUS           reduce using rule 96 (lvalue_line -> empty .)


state 42

    (25) vardecl -> FLOAT IDENT . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (97) empty -> .

    LBRACKET        shift and go to state 66
    SEMICOLON       reduce using rule 97 (empty -> .)

    vardecl_line                   shift and go to state 69
    empty                          shift and go to state 67

state 43

    (26) vardecl -> STRING IDENT . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (97) empty -> .

    LBRACKET        shift and go to state 66
    SEMICOLON       reduce using rule 97 (empty -> .)

    vardecl_line                   shift and go to state 70
    empty                          shift and go to state 67

state 44

    (29) atribstat -> lvalue ASSIGN . _atribstat
    (30) _atribstat -> . INT_CONSTANT term_line _expression
    (31) _atribstat -> . FLOAT_CONSTANT term_line _expression
    (32) _atribstat -> . STRING_CONSTANT term_line _expression
    (33) _atribstat -> . NULL term_line _expression
    (34) _atribstat -> . IDENT __atribstat
    (35) _atribstat -> . LPAREN numexpression RPAREN term_line _expression
    (36) _atribstat -> . PLUS _numexpression _expression
    (37) _atribstat -> . MINUS _numexpression _expression
    (38) _atribstat -> . _expression
    (39) _atribstat -> . allocexpression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression
    (57) allocexpression -> . NEW _allocexpression

    INT_CONSTANT    shift and go to state 72
    FLOAT_CONSTANT  shift and go to state 74
    STRING_CONSTANT shift and go to state 75
    NULL            shift and go to state 76
    IDENT           shift and go to state 77
    LPAREN          shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87
    NEW             shift and go to state 88

    _atribstat                     shift and go to state 71
    _expression                    shift and go to state 73
    allocexpression                shift and go to state 81

state 45

    (47) printstat -> PRINT expression .

    SEMICOLON       reduce using rule 47 (printstat -> PRINT expression .)


state 46

    (64) expression -> numexpression . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 89

state 47

    (71) numexpression -> factor . term_line
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 90
    empty                          shift and go to state 94

state 48

    (72) numexpression -> PLUS . _numexpression
    (75) _numexpression -> . factor term_line
    (76) _numexpression -> . term numexpression_line
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (80) term -> . unaryexpre term_line
    (94) lvalue -> . IDENT lvalue_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor

    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17
    PLUS            shift and go to state 95
    MINUS           shift and go to state 100

    _numexpression                 shift and go to state 96
    factor                         shift and go to state 97
    term                           shift and go to state 98
    lvalue                         shift and go to state 55
    unaryexpre                     shift and go to state 99

state 49

    (73) numexpression -> MINUS . _numexpression
    (75) _numexpression -> . factor term_line
    (76) _numexpression -> . term numexpression_line
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (80) term -> . unaryexpre term_line
    (94) lvalue -> . IDENT lvalue_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor

    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17
    PLUS            shift and go to state 95
    MINUS           shift and go to state 100

    _numexpression                 shift and go to state 101
    factor                         shift and go to state 97
    term                           shift and go to state 98
    lvalue                         shift and go to state 55
    unaryexpre                     shift and go to state 99

state 50

    (74) numexpression -> empty .

    LESS_THAN       reduce using rule 74 (numexpression -> empty .)
    GREATER_THAN    reduce using rule 74 (numexpression -> empty .)
    LESS_EQUAL_THAN reduce using rule 74 (numexpression -> empty .)
    GREATER_EQUAL_THAN reduce using rule 74 (numexpression -> empty .)
    EQUAL_TO        reduce using rule 74 (numexpression -> empty .)
    NOT_EQUAL_TO    reduce using rule 74 (numexpression -> empty .)
    RBRACKET        reduce using rule 74 (numexpression -> empty .)
    RPAREN          reduce using rule 74 (numexpression -> empty .)
    SEMICOLON       reduce using rule 74 (numexpression -> empty .)


state 51

    (88) factor -> INT_CONSTANT .

    TIMES           reduce using rule 88 (factor -> INT_CONSTANT .)
    DIVIDE          reduce using rule 88 (factor -> INT_CONSTANT .)
    MODULO          reduce using rule 88 (factor -> INT_CONSTANT .)
    LESS_THAN       reduce using rule 88 (factor -> INT_CONSTANT .)
    GREATER_THAN    reduce using rule 88 (factor -> INT_CONSTANT .)
    LESS_EQUAL_THAN reduce using rule 88 (factor -> INT_CONSTANT .)
    GREATER_EQUAL_THAN reduce using rule 88 (factor -> INT_CONSTANT .)
    EQUAL_TO        reduce using rule 88 (factor -> INT_CONSTANT .)
    NOT_EQUAL_TO    reduce using rule 88 (factor -> INT_CONSTANT .)
    RBRACKET        reduce using rule 88 (factor -> INT_CONSTANT .)
    RPAREN          reduce using rule 88 (factor -> INT_CONSTANT .)
    SEMICOLON       reduce using rule 88 (factor -> INT_CONSTANT .)
    PLUS            reduce using rule 88 (factor -> INT_CONSTANT .)
    MINUS           reduce using rule 88 (factor -> INT_CONSTANT .)


state 52

    (89) factor -> FLOAT_CONSTANT .

    TIMES           reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    DIVIDE          reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    MODULO          reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    LESS_THAN       reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    GREATER_THAN    reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    LESS_EQUAL_THAN reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    GREATER_EQUAL_THAN reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    EQUAL_TO        reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    NOT_EQUAL_TO    reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    RBRACKET        reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    RPAREN          reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    SEMICOLON       reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    PLUS            reduce using rule 89 (factor -> FLOAT_CONSTANT .)
    MINUS           reduce using rule 89 (factor -> FLOAT_CONSTANT .)


state 53

    (90) factor -> STRING_CONSTANT .

    TIMES           reduce using rule 90 (factor -> STRING_CONSTANT .)
    DIVIDE          reduce using rule 90 (factor -> STRING_CONSTANT .)
    MODULO          reduce using rule 90 (factor -> STRING_CONSTANT .)
    LESS_THAN       reduce using rule 90 (factor -> STRING_CONSTANT .)
    GREATER_THAN    reduce using rule 90 (factor -> STRING_CONSTANT .)
    LESS_EQUAL_THAN reduce using rule 90 (factor -> STRING_CONSTANT .)
    GREATER_EQUAL_THAN reduce using rule 90 (factor -> STRING_CONSTANT .)
    EQUAL_TO        reduce using rule 90 (factor -> STRING_CONSTANT .)
    NOT_EQUAL_TO    reduce using rule 90 (factor -> STRING_CONSTANT .)
    RBRACKET        reduce using rule 90 (factor -> STRING_CONSTANT .)
    RPAREN          reduce using rule 90 (factor -> STRING_CONSTANT .)
    SEMICOLON       reduce using rule 90 (factor -> STRING_CONSTANT .)
    PLUS            reduce using rule 90 (factor -> STRING_CONSTANT .)
    MINUS           reduce using rule 90 (factor -> STRING_CONSTANT .)


state 54

    (91) factor -> NULL .

    TIMES           reduce using rule 91 (factor -> NULL .)
    DIVIDE          reduce using rule 91 (factor -> NULL .)
    MODULO          reduce using rule 91 (factor -> NULL .)
    LESS_THAN       reduce using rule 91 (factor -> NULL .)
    GREATER_THAN    reduce using rule 91 (factor -> NULL .)
    LESS_EQUAL_THAN reduce using rule 91 (factor -> NULL .)
    GREATER_EQUAL_THAN reduce using rule 91 (factor -> NULL .)
    EQUAL_TO        reduce using rule 91 (factor -> NULL .)
    NOT_EQUAL_TO    reduce using rule 91 (factor -> NULL .)
    RBRACKET        reduce using rule 91 (factor -> NULL .)
    RPAREN          reduce using rule 91 (factor -> NULL .)
    SEMICOLON       reduce using rule 91 (factor -> NULL .)
    PLUS            reduce using rule 91 (factor -> NULL .)
    MINUS           reduce using rule 91 (factor -> NULL .)


state 55

    (92) factor -> lvalue .

    TIMES           reduce using rule 92 (factor -> lvalue .)
    DIVIDE          reduce using rule 92 (factor -> lvalue .)
    MODULO          reduce using rule 92 (factor -> lvalue .)
    LESS_THAN       reduce using rule 92 (factor -> lvalue .)
    GREATER_THAN    reduce using rule 92 (factor -> lvalue .)
    LESS_EQUAL_THAN reduce using rule 92 (factor -> lvalue .)
    GREATER_EQUAL_THAN reduce using rule 92 (factor -> lvalue .)
    EQUAL_TO        reduce using rule 92 (factor -> lvalue .)
    NOT_EQUAL_TO    reduce using rule 92 (factor -> lvalue .)
    RBRACKET        reduce using rule 92 (factor -> lvalue .)
    RPAREN          reduce using rule 92 (factor -> lvalue .)
    SEMICOLON       reduce using rule 92 (factor -> lvalue .)
    PLUS            reduce using rule 92 (factor -> lvalue .)
    MINUS           reduce using rule 92 (factor -> lvalue .)


state 56

    (93) factor -> LPAREN . numexpression RPAREN
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 102
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 57

    (48) readstat -> READ lvalue .

    SEMICOLON       reduce using rule 48 (readstat -> READ lvalue .)


state 58

    (50) ifstat -> IF LPAREN . expression RPAREN statement _ifstat
    (64) expression -> . numexpression _expression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    expression                     shift and go to state 103
    numexpression                  shift and go to state 46
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 59

    (53) forstat -> FOR LPAREN . atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (94) lvalue -> . IDENT lvalue_line

    IDENT           shift and go to state 17

    atribstat                      shift and go to state 104
    lvalue                         shift and go to state 20

state 60

    (7) funcdef -> DEFINE IDENT . LPAREN paramlist RPAREN LBRACES statelist RBRACES

    LPAREN          shift and go to state 105


state 61

    (21) statement -> LBRACES statelist RBRACES .

    $end            reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    LBRACES         reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    BREAK           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    SEMICOLON       reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    INT             reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    FLOAT           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    STRING          reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    PRINT           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    READ            reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    RETURN          reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    IF              reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    FOR             reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    IDENT           reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    RBRACES         reduce using rule 21 (statement -> LBRACES statelist RBRACES .)
    ELSE            reduce using rule 21 (statement -> LBRACES statelist RBRACES .)


state 62

    (54) statelist -> statement _statelist .

    RBRACES         reduce using rule 54 (statelist -> statement _statelist .)


state 63

    (55) _statelist -> statelist .

    RBRACES         reduce using rule 55 (_statelist -> statelist .)


state 64

    (56) _statelist -> empty .

    RBRACES         reduce using rule 56 (_statelist -> empty .)


state 65

    (24) vardecl -> INT IDENT vardecl_line .

    SEMICOLON       reduce using rule 24 (vardecl -> INT IDENT vardecl_line .)


state 66

    (27) vardecl_line -> LBRACKET . INT_CONSTANT RBRACKET vardecl_line

    INT_CONSTANT    shift and go to state 106


state 67

    (28) vardecl_line -> empty .

    SEMICOLON       reduce using rule 28 (vardecl_line -> empty .)


state 68

    (95) lvalue_line -> LBRACKET numexpression . RBRACKET lvalue_line

    RBRACKET        shift and go to state 107


state 69

    (25) vardecl -> FLOAT IDENT vardecl_line .

    SEMICOLON       reduce using rule 25 (vardecl -> FLOAT IDENT vardecl_line .)


state 70

    (26) vardecl -> STRING IDENT vardecl_line .

    SEMICOLON       reduce using rule 26 (vardecl -> STRING IDENT vardecl_line .)


state 71

    (29) atribstat -> lvalue ASSIGN _atribstat .

    SEMICOLON       reduce using rule 29 (atribstat -> lvalue ASSIGN _atribstat .)
    RPAREN          reduce using rule 29 (atribstat -> lvalue ASSIGN _atribstat .)


state 72

    (30) _atribstat -> INT_CONSTANT . term_line _expression
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 108
    empty                          shift and go to state 94

state 73

    (38) _atribstat -> _expression .

    SEMICOLON       reduce using rule 38 (_atribstat -> _expression .)
    RPAREN          reduce using rule 38 (_atribstat -> _expression .)


state 74

    (31) _atribstat -> FLOAT_CONSTANT . term_line _expression
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 109
    empty                          shift and go to state 94

state 75

    (32) _atribstat -> STRING_CONSTANT . term_line _expression
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 110
    empty                          shift and go to state 94

state 76

    (33) _atribstat -> NULL . term_line _expression
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 111
    empty                          shift and go to state 94

state 77

    (34) _atribstat -> IDENT . __atribstat
    (40) __atribstat -> . lvalue_line term_line _expression
    (41) __atribstat -> . LPAREN paramlistcall RPAREN
    (95) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (96) lvalue_line -> . empty
    (97) empty -> .

    LPAREN          shift and go to state 114
    LBRACKET        shift and go to state 40
    TIMES           reduce using rule 97 (empty -> .)
    DIVIDE          reduce using rule 97 (empty -> .)
    MODULO          reduce using rule 97 (empty -> .)
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    __atribstat                    shift and go to state 112
    lvalue_line                    shift and go to state 113
    empty                          shift and go to state 41

state 78

    (35) _atribstat -> LPAREN . numexpression RPAREN term_line _expression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 115
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 79

    (36) _atribstat -> PLUS . _numexpression _expression
    (75) _numexpression -> . factor term_line
    (76) _numexpression -> . term numexpression_line
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (80) term -> . unaryexpre term_line
    (94) lvalue -> . IDENT lvalue_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor

    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17
    PLUS            shift and go to state 95
    MINUS           shift and go to state 100

    _numexpression                 shift and go to state 116
    factor                         shift and go to state 97
    term                           shift and go to state 98
    lvalue                         shift and go to state 55
    unaryexpre                     shift and go to state 99

state 80

    (37) _atribstat -> MINUS . _numexpression _expression
    (75) _numexpression -> . factor term_line
    (76) _numexpression -> . term numexpression_line
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (80) term -> . unaryexpre term_line
    (94) lvalue -> . IDENT lvalue_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor

    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17
    PLUS            shift and go to state 95
    MINUS           shift and go to state 100

    _numexpression                 shift and go to state 117
    factor                         shift and go to state 97
    term                           shift and go to state 98
    lvalue                         shift and go to state 55
    unaryexpre                     shift and go to state 99

state 81

    (39) _atribstat -> allocexpression .

    SEMICOLON       reduce using rule 39 (_atribstat -> allocexpression .)
    RPAREN          reduce using rule 39 (_atribstat -> allocexpression .)


state 82

    (65) _expression -> LESS_THAN . numexpression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 118
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 83

    (66) _expression -> GREATER_THAN . numexpression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 119
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 84

    (67) _expression -> LESS_EQUAL_THAN . numexpression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 120
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 85

    (68) _expression -> GREATER_EQUAL_THAN . numexpression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 121
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 86

    (69) _expression -> EQUAL_TO . numexpression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 122
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 87

    (70) _expression -> NOT_EQUAL_TO . numexpression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 123
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 88

    (57) allocexpression -> NEW . _allocexpression
    (58) _allocexpression -> . INT allocexpression_line
    (59) _allocexpression -> . FLOAT allocexpression_line
    (60) _allocexpression -> . STRING allocexpression_line

    INT             shift and go to state 125
    FLOAT           shift and go to state 126
    STRING          shift and go to state 127

    _allocexpression               shift and go to state 124

state 89

    (64) expression -> numexpression _expression .

    SEMICOLON       reduce using rule 64 (expression -> numexpression _expression .)
    RPAREN          reduce using rule 64 (expression -> numexpression _expression .)


state 90

    (71) numexpression -> factor term_line .

    LESS_THAN       reduce using rule 71 (numexpression -> factor term_line .)
    GREATER_THAN    reduce using rule 71 (numexpression -> factor term_line .)
    LESS_EQUAL_THAN reduce using rule 71 (numexpression -> factor term_line .)
    GREATER_EQUAL_THAN reduce using rule 71 (numexpression -> factor term_line .)
    EQUAL_TO        reduce using rule 71 (numexpression -> factor term_line .)
    NOT_EQUAL_TO    reduce using rule 71 (numexpression -> factor term_line .)
    RBRACKET        reduce using rule 71 (numexpression -> factor term_line .)
    RPAREN          reduce using rule 71 (numexpression -> factor term_line .)
    SEMICOLON       reduce using rule 71 (numexpression -> factor term_line .)


state 91

    (81) term_line -> TIMES . unaryexpre term_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 95
    MINUS           shift and go to state 100
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    unaryexpre                     shift and go to state 128
    factor                         shift and go to state 129
    lvalue                         shift and go to state 55

state 92

    (82) term_line -> DIVIDE . unaryexpre term_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 95
    MINUS           shift and go to state 100
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    unaryexpre                     shift and go to state 130
    factor                         shift and go to state 129
    lvalue                         shift and go to state 55

state 93

    (83) term_line -> MODULO . unaryexpre term_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 95
    MINUS           shift and go to state 100
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    unaryexpre                     shift and go to state 131
    factor                         shift and go to state 129
    lvalue                         shift and go to state 55

state 94

    (84) term_line -> empty .

    LESS_THAN       reduce using rule 84 (term_line -> empty .)
    GREATER_THAN    reduce using rule 84 (term_line -> empty .)
    LESS_EQUAL_THAN reduce using rule 84 (term_line -> empty .)
    GREATER_EQUAL_THAN reduce using rule 84 (term_line -> empty .)
    EQUAL_TO        reduce using rule 84 (term_line -> empty .)
    NOT_EQUAL_TO    reduce using rule 84 (term_line -> empty .)
    RBRACKET        reduce using rule 84 (term_line -> empty .)
    RPAREN          reduce using rule 84 (term_line -> empty .)
    SEMICOLON       reduce using rule 84 (term_line -> empty .)
    PLUS            reduce using rule 84 (term_line -> empty .)
    MINUS           reduce using rule 84 (term_line -> empty .)


state 95

    (86) unaryexpre -> PLUS . factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    factor                         shift and go to state 132
    lvalue                         shift and go to state 55

state 96

    (72) numexpression -> PLUS _numexpression .

    LESS_THAN       reduce using rule 72 (numexpression -> PLUS _numexpression .)
    GREATER_THAN    reduce using rule 72 (numexpression -> PLUS _numexpression .)
    LESS_EQUAL_THAN reduce using rule 72 (numexpression -> PLUS _numexpression .)
    GREATER_EQUAL_THAN reduce using rule 72 (numexpression -> PLUS _numexpression .)
    EQUAL_TO        reduce using rule 72 (numexpression -> PLUS _numexpression .)
    NOT_EQUAL_TO    reduce using rule 72 (numexpression -> PLUS _numexpression .)
    RBRACKET        reduce using rule 72 (numexpression -> PLUS _numexpression .)
    RPAREN          reduce using rule 72 (numexpression -> PLUS _numexpression .)
    SEMICOLON       reduce using rule 72 (numexpression -> PLUS _numexpression .)


state 97

    (75) _numexpression -> factor . term_line
    (85) unaryexpre -> factor .
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULO resolved as shift
  ! reduce/reduce conflict for LESS_THAN resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for LESS_EQUAL_THAN resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for GREATER_EQUAL_THAN resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for EQUAL_TO resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for NOT_EQUAL_TO resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for RPAREN resolved using rule 85 (unaryexpre -> factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 85 (unaryexpre -> factor .)
    PLUS            reduce using rule 85 (unaryexpre -> factor .)
    MINUS           reduce using rule 85 (unaryexpre -> factor .)
    LESS_THAN       reduce using rule 85 (unaryexpre -> factor .)
    GREATER_THAN    reduce using rule 85 (unaryexpre -> factor .)
    LESS_EQUAL_THAN reduce using rule 85 (unaryexpre -> factor .)
    GREATER_EQUAL_THAN reduce using rule 85 (unaryexpre -> factor .)
    EQUAL_TO        reduce using rule 85 (unaryexpre -> factor .)
    NOT_EQUAL_TO    reduce using rule 85 (unaryexpre -> factor .)
    RBRACKET        reduce using rule 85 (unaryexpre -> factor .)
    RPAREN          reduce using rule 85 (unaryexpre -> factor .)
    SEMICOLON       reduce using rule 85 (unaryexpre -> factor .)
    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93

  ! TIMES           [ reduce using rule 85 (unaryexpre -> factor .) ]
  ! DIVIDE          [ reduce using rule 85 (unaryexpre -> factor .) ]
  ! MODULO          [ reduce using rule 85 (unaryexpre -> factor .) ]
  ! LESS_THAN       [ reduce using rule 97 (empty -> .) ]
  ! GREATER_THAN    [ reduce using rule 97 (empty -> .) ]
  ! LESS_EQUAL_THAN [ reduce using rule 97 (empty -> .) ]
  ! GREATER_EQUAL_THAN [ reduce using rule 97 (empty -> .) ]
  ! EQUAL_TO        [ reduce using rule 97 (empty -> .) ]
  ! NOT_EQUAL_TO    [ reduce using rule 97 (empty -> .) ]
  ! RBRACKET        [ reduce using rule 97 (empty -> .) ]
  ! RPAREN          [ reduce using rule 97 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 97 (empty -> .) ]

    term_line                      shift and go to state 133
    empty                          shift and go to state 94

state 98

    (76) _numexpression -> term . numexpression_line
    (77) numexpression_line -> . PLUS term numexpression_line
    (78) numexpression_line -> . MINUS term numexpression_line
    (79) numexpression_line -> . empty
    (97) empty -> .

    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)

    numexpression_line             shift and go to state 134
    empty                          shift and go to state 137

state 99

    (80) term -> unaryexpre . term_line
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    PLUS            reduce using rule 97 (empty -> .)
    MINUS           reduce using rule 97 (empty -> .)
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 138
    empty                          shift and go to state 94

state 100

    (87) unaryexpre -> MINUS . factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    factor                         shift and go to state 139
    lvalue                         shift and go to state 55

state 101

    (73) numexpression -> MINUS _numexpression .

    LESS_THAN       reduce using rule 73 (numexpression -> MINUS _numexpression .)
    GREATER_THAN    reduce using rule 73 (numexpression -> MINUS _numexpression .)
    LESS_EQUAL_THAN reduce using rule 73 (numexpression -> MINUS _numexpression .)
    GREATER_EQUAL_THAN reduce using rule 73 (numexpression -> MINUS _numexpression .)
    EQUAL_TO        reduce using rule 73 (numexpression -> MINUS _numexpression .)
    NOT_EQUAL_TO    reduce using rule 73 (numexpression -> MINUS _numexpression .)
    RBRACKET        reduce using rule 73 (numexpression -> MINUS _numexpression .)
    RPAREN          reduce using rule 73 (numexpression -> MINUS _numexpression .)
    SEMICOLON       reduce using rule 73 (numexpression -> MINUS _numexpression .)


state 102

    (93) factor -> LPAREN numexpression . RPAREN

    RPAREN          shift and go to state 140


state 103

    (50) ifstat -> IF LPAREN expression . RPAREN statement _ifstat

    RPAREN          shift and go to state 141


state 104

    (53) forstat -> FOR LPAREN atribstat . SEMICOLON expression SEMICOLON atribstat RPAREN statement

    SEMICOLON       shift and go to state 142


state 105

    (7) funcdef -> DEFINE IDENT LPAREN . paramlist RPAREN LBRACES statelist RBRACES
    (8) paramlist -> . INT IDENT _paramlist
    (9) paramlist -> . FLOAT IDENT _paramlist
    (10) paramlist -> . STRING IDENT _paramlist
    (11) paramlist -> . empty
    (97) empty -> .

    INT             shift and go to state 144
    FLOAT           shift and go to state 145
    STRING          shift and go to state 146
    RPAREN          reduce using rule 97 (empty -> .)

    paramlist                      shift and go to state 143
    empty                          shift and go to state 147

state 106

    (27) vardecl_line -> LBRACKET INT_CONSTANT . RBRACKET vardecl_line

    RBRACKET        shift and go to state 148


state 107

    (95) lvalue_line -> LBRACKET numexpression RBRACKET . lvalue_line
    (95) lvalue_line -> . LBRACKET numexpression RBRACKET lvalue_line
    (96) lvalue_line -> . empty
    (97) empty -> .

    LBRACKET        shift and go to state 40
    ASSIGN          reduce using rule 97 (empty -> .)
    TIMES           reduce using rule 97 (empty -> .)
    DIVIDE          reduce using rule 97 (empty -> .)
    MODULO          reduce using rule 97 (empty -> .)
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    PLUS            reduce using rule 97 (empty -> .)
    MINUS           reduce using rule 97 (empty -> .)

    lvalue_line                    shift and go to state 149
    empty                          shift and go to state 41

state 108

    (30) _atribstat -> INT_CONSTANT term_line . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 150

state 109

    (31) _atribstat -> FLOAT_CONSTANT term_line . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 151

state 110

    (32) _atribstat -> STRING_CONSTANT term_line . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 152

state 111

    (33) _atribstat -> NULL term_line . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 153

state 112

    (34) _atribstat -> IDENT __atribstat .

    SEMICOLON       reduce using rule 34 (_atribstat -> IDENT __atribstat .)
    RPAREN          reduce using rule 34 (_atribstat -> IDENT __atribstat .)


state 113

    (40) __atribstat -> lvalue_line . term_line _expression
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 154
    empty                          shift and go to state 94

state 114

    (41) __atribstat -> LPAREN . paramlistcall RPAREN
    (43) paramlistcall -> . IDENT _paramlistcall
    (44) paramlistcall -> . empty
    (97) empty -> .

    IDENT           shift and go to state 156
    RPAREN          reduce using rule 97 (empty -> .)

    paramlistcall                  shift and go to state 155
    empty                          shift and go to state 157

state 115

    (35) _atribstat -> LPAREN numexpression . RPAREN term_line _expression

    RPAREN          shift and go to state 158


state 116

    (36) _atribstat -> PLUS _numexpression . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 159

state 117

    (37) _atribstat -> MINUS _numexpression . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 160

state 118

    (65) _expression -> LESS_THAN numexpression .

    SEMICOLON       reduce using rule 65 (_expression -> LESS_THAN numexpression .)
    RPAREN          reduce using rule 65 (_expression -> LESS_THAN numexpression .)


state 119

    (66) _expression -> GREATER_THAN numexpression .

    SEMICOLON       reduce using rule 66 (_expression -> GREATER_THAN numexpression .)
    RPAREN          reduce using rule 66 (_expression -> GREATER_THAN numexpression .)


state 120

    (67) _expression -> LESS_EQUAL_THAN numexpression .

    SEMICOLON       reduce using rule 67 (_expression -> LESS_EQUAL_THAN numexpression .)
    RPAREN          reduce using rule 67 (_expression -> LESS_EQUAL_THAN numexpression .)


state 121

    (68) _expression -> GREATER_EQUAL_THAN numexpression .

    SEMICOLON       reduce using rule 68 (_expression -> GREATER_EQUAL_THAN numexpression .)
    RPAREN          reduce using rule 68 (_expression -> GREATER_EQUAL_THAN numexpression .)


state 122

    (69) _expression -> EQUAL_TO numexpression .

    SEMICOLON       reduce using rule 69 (_expression -> EQUAL_TO numexpression .)
    RPAREN          reduce using rule 69 (_expression -> EQUAL_TO numexpression .)


state 123

    (70) _expression -> NOT_EQUAL_TO numexpression .

    SEMICOLON       reduce using rule 70 (_expression -> NOT_EQUAL_TO numexpression .)
    RPAREN          reduce using rule 70 (_expression -> NOT_EQUAL_TO numexpression .)


state 124

    (57) allocexpression -> NEW _allocexpression .

    SEMICOLON       reduce using rule 57 (allocexpression -> NEW _allocexpression .)
    RPAREN          reduce using rule 57 (allocexpression -> NEW _allocexpression .)


state 125

    (58) _allocexpression -> INT . allocexpression_line
    (61) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line

    LBRACKET        shift and go to state 162

    allocexpression_line           shift and go to state 161

state 126

    (59) _allocexpression -> FLOAT . allocexpression_line
    (61) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line

    LBRACKET        shift and go to state 162

    allocexpression_line           shift and go to state 163

state 127

    (60) _allocexpression -> STRING . allocexpression_line
    (61) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line

    LBRACKET        shift and go to state 162

    allocexpression_line           shift and go to state 164

state 128

    (81) term_line -> TIMES unaryexpre . term_line
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)
    PLUS            reduce using rule 97 (empty -> .)
    MINUS           reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 165
    empty                          shift and go to state 94

state 129

    (85) unaryexpre -> factor .

    TIMES           reduce using rule 85 (unaryexpre -> factor .)
    DIVIDE          reduce using rule 85 (unaryexpre -> factor .)
    MODULO          reduce using rule 85 (unaryexpre -> factor .)
    LESS_THAN       reduce using rule 85 (unaryexpre -> factor .)
    GREATER_THAN    reduce using rule 85 (unaryexpre -> factor .)
    LESS_EQUAL_THAN reduce using rule 85 (unaryexpre -> factor .)
    GREATER_EQUAL_THAN reduce using rule 85 (unaryexpre -> factor .)
    EQUAL_TO        reduce using rule 85 (unaryexpre -> factor .)
    NOT_EQUAL_TO    reduce using rule 85 (unaryexpre -> factor .)
    RBRACKET        reduce using rule 85 (unaryexpre -> factor .)
    RPAREN          reduce using rule 85 (unaryexpre -> factor .)
    SEMICOLON       reduce using rule 85 (unaryexpre -> factor .)
    PLUS            reduce using rule 85 (unaryexpre -> factor .)
    MINUS           reduce using rule 85 (unaryexpre -> factor .)


state 130

    (82) term_line -> DIVIDE unaryexpre . term_line
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)
    PLUS            reduce using rule 97 (empty -> .)
    MINUS           reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 166
    empty                          shift and go to state 94

state 131

    (83) term_line -> MODULO unaryexpre . term_line
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)
    PLUS            reduce using rule 97 (empty -> .)
    MINUS           reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 167
    empty                          shift and go to state 94

state 132

    (86) unaryexpre -> PLUS factor .

    TIMES           reduce using rule 86 (unaryexpre -> PLUS factor .)
    DIVIDE          reduce using rule 86 (unaryexpre -> PLUS factor .)
    MODULO          reduce using rule 86 (unaryexpre -> PLUS factor .)
    PLUS            reduce using rule 86 (unaryexpre -> PLUS factor .)
    MINUS           reduce using rule 86 (unaryexpre -> PLUS factor .)
    LESS_THAN       reduce using rule 86 (unaryexpre -> PLUS factor .)
    GREATER_THAN    reduce using rule 86 (unaryexpre -> PLUS factor .)
    LESS_EQUAL_THAN reduce using rule 86 (unaryexpre -> PLUS factor .)
    GREATER_EQUAL_THAN reduce using rule 86 (unaryexpre -> PLUS factor .)
    EQUAL_TO        reduce using rule 86 (unaryexpre -> PLUS factor .)
    NOT_EQUAL_TO    reduce using rule 86 (unaryexpre -> PLUS factor .)
    RBRACKET        reduce using rule 86 (unaryexpre -> PLUS factor .)
    RPAREN          reduce using rule 86 (unaryexpre -> PLUS factor .)
    SEMICOLON       reduce using rule 86 (unaryexpre -> PLUS factor .)


state 133

    (75) _numexpression -> factor term_line .

    LESS_THAN       reduce using rule 75 (_numexpression -> factor term_line .)
    GREATER_THAN    reduce using rule 75 (_numexpression -> factor term_line .)
    LESS_EQUAL_THAN reduce using rule 75 (_numexpression -> factor term_line .)
    GREATER_EQUAL_THAN reduce using rule 75 (_numexpression -> factor term_line .)
    EQUAL_TO        reduce using rule 75 (_numexpression -> factor term_line .)
    NOT_EQUAL_TO    reduce using rule 75 (_numexpression -> factor term_line .)
    RBRACKET        reduce using rule 75 (_numexpression -> factor term_line .)
    RPAREN          reduce using rule 75 (_numexpression -> factor term_line .)
    SEMICOLON       reduce using rule 75 (_numexpression -> factor term_line .)


state 134

    (76) _numexpression -> term numexpression_line .

    LESS_THAN       reduce using rule 76 (_numexpression -> term numexpression_line .)
    GREATER_THAN    reduce using rule 76 (_numexpression -> term numexpression_line .)
    LESS_EQUAL_THAN reduce using rule 76 (_numexpression -> term numexpression_line .)
    GREATER_EQUAL_THAN reduce using rule 76 (_numexpression -> term numexpression_line .)
    EQUAL_TO        reduce using rule 76 (_numexpression -> term numexpression_line .)
    NOT_EQUAL_TO    reduce using rule 76 (_numexpression -> term numexpression_line .)
    RBRACKET        reduce using rule 76 (_numexpression -> term numexpression_line .)
    RPAREN          reduce using rule 76 (_numexpression -> term numexpression_line .)
    SEMICOLON       reduce using rule 76 (_numexpression -> term numexpression_line .)


state 135

    (77) numexpression_line -> PLUS . term numexpression_line
    (80) term -> . unaryexpre term_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 95
    MINUS           shift and go to state 100
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    term                           shift and go to state 168
    unaryexpre                     shift and go to state 99
    factor                         shift and go to state 129
    lvalue                         shift and go to state 55

state 136

    (78) numexpression_line -> MINUS . term numexpression_line
    (80) term -> . unaryexpre term_line
    (85) unaryexpre -> . factor
    (86) unaryexpre -> . PLUS factor
    (87) unaryexpre -> . MINUS factor
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 95
    MINUS           shift and go to state 100
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    IDENT           shift and go to state 17

    term                           shift and go to state 169
    unaryexpre                     shift and go to state 99
    factor                         shift and go to state 129
    lvalue                         shift and go to state 55

state 137

    (79) numexpression_line -> empty .

    LESS_THAN       reduce using rule 79 (numexpression_line -> empty .)
    GREATER_THAN    reduce using rule 79 (numexpression_line -> empty .)
    LESS_EQUAL_THAN reduce using rule 79 (numexpression_line -> empty .)
    GREATER_EQUAL_THAN reduce using rule 79 (numexpression_line -> empty .)
    EQUAL_TO        reduce using rule 79 (numexpression_line -> empty .)
    NOT_EQUAL_TO    reduce using rule 79 (numexpression_line -> empty .)
    RBRACKET        reduce using rule 79 (numexpression_line -> empty .)
    RPAREN          reduce using rule 79 (numexpression_line -> empty .)
    SEMICOLON       reduce using rule 79 (numexpression_line -> empty .)


state 138

    (80) term -> unaryexpre term_line .

    PLUS            reduce using rule 80 (term -> unaryexpre term_line .)
    MINUS           reduce using rule 80 (term -> unaryexpre term_line .)
    LESS_THAN       reduce using rule 80 (term -> unaryexpre term_line .)
    GREATER_THAN    reduce using rule 80 (term -> unaryexpre term_line .)
    LESS_EQUAL_THAN reduce using rule 80 (term -> unaryexpre term_line .)
    GREATER_EQUAL_THAN reduce using rule 80 (term -> unaryexpre term_line .)
    EQUAL_TO        reduce using rule 80 (term -> unaryexpre term_line .)
    NOT_EQUAL_TO    reduce using rule 80 (term -> unaryexpre term_line .)
    RBRACKET        reduce using rule 80 (term -> unaryexpre term_line .)
    RPAREN          reduce using rule 80 (term -> unaryexpre term_line .)
    SEMICOLON       reduce using rule 80 (term -> unaryexpre term_line .)


state 139

    (87) unaryexpre -> MINUS factor .

    TIMES           reduce using rule 87 (unaryexpre -> MINUS factor .)
    DIVIDE          reduce using rule 87 (unaryexpre -> MINUS factor .)
    MODULO          reduce using rule 87 (unaryexpre -> MINUS factor .)
    PLUS            reduce using rule 87 (unaryexpre -> MINUS factor .)
    MINUS           reduce using rule 87 (unaryexpre -> MINUS factor .)
    LESS_THAN       reduce using rule 87 (unaryexpre -> MINUS factor .)
    GREATER_THAN    reduce using rule 87 (unaryexpre -> MINUS factor .)
    LESS_EQUAL_THAN reduce using rule 87 (unaryexpre -> MINUS factor .)
    GREATER_EQUAL_THAN reduce using rule 87 (unaryexpre -> MINUS factor .)
    EQUAL_TO        reduce using rule 87 (unaryexpre -> MINUS factor .)
    NOT_EQUAL_TO    reduce using rule 87 (unaryexpre -> MINUS factor .)
    RBRACKET        reduce using rule 87 (unaryexpre -> MINUS factor .)
    RPAREN          reduce using rule 87 (unaryexpre -> MINUS factor .)
    SEMICOLON       reduce using rule 87 (unaryexpre -> MINUS factor .)


state 140

    (93) factor -> LPAREN numexpression RPAREN .

    TIMES           reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    DIVIDE          reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    MODULO          reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    LESS_THAN       reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    GREATER_THAN    reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    LESS_EQUAL_THAN reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    GREATER_EQUAL_THAN reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    EQUAL_TO        reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    NOT_EQUAL_TO    reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    RBRACKET        reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    RPAREN          reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    SEMICOLON       reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    PLUS            reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)
    MINUS           reduce using rule 93 (factor -> LPAREN numexpression RPAREN .)


state 141

    (50) ifstat -> IF LPAREN expression RPAREN . statement _ifstat
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (94) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    IDENT           shift and go to state 17

    statement                      shift and go to state 170
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    lvalue                         shift and go to state 20

state 142

    (53) forstat -> FOR LPAREN atribstat SEMICOLON . expression SEMICOLON atribstat RPAREN statement
    (64) expression -> . numexpression _expression
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    expression                     shift and go to state 171
    numexpression                  shift and go to state 46
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 143

    (7) funcdef -> DEFINE IDENT LPAREN paramlist . RPAREN LBRACES statelist RBRACES

    RPAREN          shift and go to state 172


state 144

    (8) paramlist -> INT . IDENT _paramlist

    IDENT           shift and go to state 173


state 145

    (9) paramlist -> FLOAT . IDENT _paramlist

    IDENT           shift and go to state 174


state 146

    (10) paramlist -> STRING . IDENT _paramlist

    IDENT           shift and go to state 175


state 147

    (11) paramlist -> empty .

    RPAREN          reduce using rule 11 (paramlist -> empty .)


state 148

    (27) vardecl_line -> LBRACKET INT_CONSTANT RBRACKET . vardecl_line
    (27) vardecl_line -> . LBRACKET INT_CONSTANT RBRACKET vardecl_line
    (28) vardecl_line -> . empty
    (97) empty -> .

    LBRACKET        shift and go to state 66
    SEMICOLON       reduce using rule 97 (empty -> .)

    vardecl_line                   shift and go to state 176
    empty                          shift and go to state 67

state 149

    (95) lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .

    ASSIGN          reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    TIMES           reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    DIVIDE          reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    MODULO          reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    LESS_THAN       reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    GREATER_THAN    reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    LESS_EQUAL_THAN reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    GREATER_EQUAL_THAN reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    EQUAL_TO        reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    NOT_EQUAL_TO    reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    SEMICOLON       reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    RBRACKET        reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    RPAREN          reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    PLUS            reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)
    MINUS           reduce using rule 95 (lvalue_line -> LBRACKET numexpression RBRACKET lvalue_line .)


state 150

    (30) _atribstat -> INT_CONSTANT term_line _expression .

    SEMICOLON       reduce using rule 30 (_atribstat -> INT_CONSTANT term_line _expression .)
    RPAREN          reduce using rule 30 (_atribstat -> INT_CONSTANT term_line _expression .)


state 151

    (31) _atribstat -> FLOAT_CONSTANT term_line _expression .

    SEMICOLON       reduce using rule 31 (_atribstat -> FLOAT_CONSTANT term_line _expression .)
    RPAREN          reduce using rule 31 (_atribstat -> FLOAT_CONSTANT term_line _expression .)


state 152

    (32) _atribstat -> STRING_CONSTANT term_line _expression .

    SEMICOLON       reduce using rule 32 (_atribstat -> STRING_CONSTANT term_line _expression .)
    RPAREN          reduce using rule 32 (_atribstat -> STRING_CONSTANT term_line _expression .)


state 153

    (33) _atribstat -> NULL term_line _expression .

    SEMICOLON       reduce using rule 33 (_atribstat -> NULL term_line _expression .)
    RPAREN          reduce using rule 33 (_atribstat -> NULL term_line _expression .)


state 154

    (40) __atribstat -> lvalue_line term_line . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 177

state 155

    (41) __atribstat -> LPAREN paramlistcall . RPAREN

    RPAREN          shift and go to state 178


state 156

    (43) paramlistcall -> IDENT . _paramlistcall
    (45) _paramlistcall -> . COMMA paramlistcall
    (46) _paramlistcall -> . empty
    (97) empty -> .

    COMMA           shift and go to state 180
    RPAREN          reduce using rule 97 (empty -> .)

    _paramlistcall                 shift and go to state 179
    empty                          shift and go to state 181

state 157

    (44) paramlistcall -> empty .

    RPAREN          reduce using rule 44 (paramlistcall -> empty .)


state 158

    (35) _atribstat -> LPAREN numexpression RPAREN . term_line _expression
    (81) term_line -> . TIMES unaryexpre term_line
    (82) term_line -> . DIVIDE unaryexpre term_line
    (83) term_line -> . MODULO unaryexpre term_line
    (84) term_line -> . empty
    (97) empty -> .

    TIMES           shift and go to state 91
    DIVIDE          shift and go to state 92
    MODULO          shift and go to state 93
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)

    term_line                      shift and go to state 182
    empty                          shift and go to state 94

state 159

    (36) _atribstat -> PLUS _numexpression _expression .

    SEMICOLON       reduce using rule 36 (_atribstat -> PLUS _numexpression _expression .)
    RPAREN          reduce using rule 36 (_atribstat -> PLUS _numexpression _expression .)


state 160

    (37) _atribstat -> MINUS _numexpression _expression .

    SEMICOLON       reduce using rule 37 (_atribstat -> MINUS _numexpression _expression .)
    RPAREN          reduce using rule 37 (_atribstat -> MINUS _numexpression _expression .)


state 161

    (58) _allocexpression -> INT allocexpression_line .

    SEMICOLON       reduce using rule 58 (_allocexpression -> INT allocexpression_line .)
    RPAREN          reduce using rule 58 (_allocexpression -> INT allocexpression_line .)


state 162

    (61) allocexpression_line -> LBRACKET . numexpression RBRACKET _allocexpression_line
    (71) numexpression -> . factor term_line
    (72) numexpression -> . PLUS _numexpression
    (73) numexpression -> . MINUS _numexpression
    (74) numexpression -> . empty
    (88) factor -> . INT_CONSTANT
    (89) factor -> . FLOAT_CONSTANT
    (90) factor -> . STRING_CONSTANT
    (91) factor -> . NULL
    (92) factor -> . lvalue
    (93) factor -> . LPAREN numexpression RPAREN
    (97) empty -> .
    (94) lvalue -> . IDENT lvalue_line

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    INT_CONSTANT    shift and go to state 51
    FLOAT_CONSTANT  shift and go to state 52
    STRING_CONSTANT shift and go to state 53
    NULL            shift and go to state 54
    LPAREN          shift and go to state 56
    RBRACKET        reduce using rule 97 (empty -> .)
    IDENT           shift and go to state 17

    numexpression                  shift and go to state 183
    factor                         shift and go to state 47
    empty                          shift and go to state 50
    lvalue                         shift and go to state 55

state 163

    (59) _allocexpression -> FLOAT allocexpression_line .

    SEMICOLON       reduce using rule 59 (_allocexpression -> FLOAT allocexpression_line .)
    RPAREN          reduce using rule 59 (_allocexpression -> FLOAT allocexpression_line .)


state 164

    (60) _allocexpression -> STRING allocexpression_line .

    SEMICOLON       reduce using rule 60 (_allocexpression -> STRING allocexpression_line .)
    RPAREN          reduce using rule 60 (_allocexpression -> STRING allocexpression_line .)


state 165

    (81) term_line -> TIMES unaryexpre term_line .

    LESS_THAN       reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    GREATER_THAN    reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    LESS_EQUAL_THAN reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    GREATER_EQUAL_THAN reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    EQUAL_TO        reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    NOT_EQUAL_TO    reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    RBRACKET        reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    RPAREN          reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    SEMICOLON       reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    PLUS            reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)
    MINUS           reduce using rule 81 (term_line -> TIMES unaryexpre term_line .)


state 166

    (82) term_line -> DIVIDE unaryexpre term_line .

    LESS_THAN       reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    GREATER_THAN    reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    LESS_EQUAL_THAN reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    GREATER_EQUAL_THAN reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    EQUAL_TO        reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    NOT_EQUAL_TO    reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    RBRACKET        reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    RPAREN          reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    SEMICOLON       reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    PLUS            reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)
    MINUS           reduce using rule 82 (term_line -> DIVIDE unaryexpre term_line .)


state 167

    (83) term_line -> MODULO unaryexpre term_line .

    LESS_THAN       reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    GREATER_THAN    reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    LESS_EQUAL_THAN reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    GREATER_EQUAL_THAN reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    EQUAL_TO        reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    NOT_EQUAL_TO    reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    RBRACKET        reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    RPAREN          reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    SEMICOLON       reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    PLUS            reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)
    MINUS           reduce using rule 83 (term_line -> MODULO unaryexpre term_line .)


state 168

    (77) numexpression_line -> PLUS term . numexpression_line
    (77) numexpression_line -> . PLUS term numexpression_line
    (78) numexpression_line -> . MINUS term numexpression_line
    (79) numexpression_line -> . empty
    (97) empty -> .

    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)

    numexpression_line             shift and go to state 184
    empty                          shift and go to state 137

state 169

    (78) numexpression_line -> MINUS term . numexpression_line
    (77) numexpression_line -> . PLUS term numexpression_line
    (78) numexpression_line -> . MINUS term numexpression_line
    (79) numexpression_line -> . empty
    (97) empty -> .

    PLUS            shift and go to state 135
    MINUS           shift and go to state 136
    LESS_THAN       reduce using rule 97 (empty -> .)
    GREATER_THAN    reduce using rule 97 (empty -> .)
    LESS_EQUAL_THAN reduce using rule 97 (empty -> .)
    GREATER_EQUAL_THAN reduce using rule 97 (empty -> .)
    EQUAL_TO        reduce using rule 97 (empty -> .)
    NOT_EQUAL_TO    reduce using rule 97 (empty -> .)
    RBRACKET        reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)

    numexpression_line             shift and go to state 185
    empty                          shift and go to state 137

state 170

    (50) ifstat -> IF LPAREN expression RPAREN statement . _ifstat
    (51) _ifstat -> . ELSE statement
    (52) _ifstat -> . empty
    (97) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 187
    $end            reduce using rule 97 (empty -> .)
    LBRACES         reduce using rule 97 (empty -> .)
    BREAK           reduce using rule 97 (empty -> .)
    SEMICOLON       reduce using rule 97 (empty -> .)
    INT             reduce using rule 97 (empty -> .)
    FLOAT           reduce using rule 97 (empty -> .)
    STRING          reduce using rule 97 (empty -> .)
    PRINT           reduce using rule 97 (empty -> .)
    READ            reduce using rule 97 (empty -> .)
    RETURN          reduce using rule 97 (empty -> .)
    IF              reduce using rule 97 (empty -> .)
    FOR             reduce using rule 97 (empty -> .)
    IDENT           reduce using rule 97 (empty -> .)
    RBRACES         reduce using rule 97 (empty -> .)

  ! ELSE            [ reduce using rule 97 (empty -> .) ]

    _ifstat                        shift and go to state 186
    empty                          shift and go to state 188

state 171

    (53) forstat -> FOR LPAREN atribstat SEMICOLON expression . SEMICOLON atribstat RPAREN statement

    SEMICOLON       shift and go to state 189


state 172

    (7) funcdef -> DEFINE IDENT LPAREN paramlist RPAREN . LBRACES statelist RBRACES

    LBRACES         shift and go to state 190


state 173

    (8) paramlist -> INT IDENT . _paramlist
    (12) _paramlist -> . COMMA paramlist
    (13) _paramlist -> . empty
    (97) empty -> .

    COMMA           shift and go to state 192
    RPAREN          reduce using rule 97 (empty -> .)

    _paramlist                     shift and go to state 191
    empty                          shift and go to state 193

state 174

    (9) paramlist -> FLOAT IDENT . _paramlist
    (12) _paramlist -> . COMMA paramlist
    (13) _paramlist -> . empty
    (97) empty -> .

    COMMA           shift and go to state 192
    RPAREN          reduce using rule 97 (empty -> .)

    _paramlist                     shift and go to state 194
    empty                          shift and go to state 193

state 175

    (10) paramlist -> STRING IDENT . _paramlist
    (12) _paramlist -> . COMMA paramlist
    (13) _paramlist -> . empty
    (97) empty -> .

    COMMA           shift and go to state 192
    RPAREN          reduce using rule 97 (empty -> .)

    _paramlist                     shift and go to state 195
    empty                          shift and go to state 193

state 176

    (27) vardecl_line -> LBRACKET INT_CONSTANT RBRACKET vardecl_line .

    SEMICOLON       reduce using rule 27 (vardecl_line -> LBRACKET INT_CONSTANT RBRACKET vardecl_line .)


state 177

    (40) __atribstat -> lvalue_line term_line _expression .

    SEMICOLON       reduce using rule 40 (__atribstat -> lvalue_line term_line _expression .)
    RPAREN          reduce using rule 40 (__atribstat -> lvalue_line term_line _expression .)


state 178

    (41) __atribstat -> LPAREN paramlistcall RPAREN .

    SEMICOLON       reduce using rule 41 (__atribstat -> LPAREN paramlistcall RPAREN .)
    RPAREN          reduce using rule 41 (__atribstat -> LPAREN paramlistcall RPAREN .)


state 179

    (43) paramlistcall -> IDENT _paramlistcall .

    RPAREN          reduce using rule 43 (paramlistcall -> IDENT _paramlistcall .)


state 180

    (45) _paramlistcall -> COMMA . paramlistcall
    (43) paramlistcall -> . IDENT _paramlistcall
    (44) paramlistcall -> . empty
    (97) empty -> .

    IDENT           shift and go to state 156
    RPAREN          reduce using rule 97 (empty -> .)

    paramlistcall                  shift and go to state 196
    empty                          shift and go to state 157

state 181

    (46) _paramlistcall -> empty .

    RPAREN          reduce using rule 46 (_paramlistcall -> empty .)


state 182

    (35) _atribstat -> LPAREN numexpression RPAREN term_line . _expression
    (65) _expression -> . LESS_THAN numexpression
    (66) _expression -> . GREATER_THAN numexpression
    (67) _expression -> . LESS_EQUAL_THAN numexpression
    (68) _expression -> . GREATER_EQUAL_THAN numexpression
    (69) _expression -> . EQUAL_TO numexpression
    (70) _expression -> . NOT_EQUAL_TO numexpression

    LESS_THAN       shift and go to state 82
    GREATER_THAN    shift and go to state 83
    LESS_EQUAL_THAN shift and go to state 84
    GREATER_EQUAL_THAN shift and go to state 85
    EQUAL_TO        shift and go to state 86
    NOT_EQUAL_TO    shift and go to state 87

    _expression                    shift and go to state 197

state 183

    (61) allocexpression_line -> LBRACKET numexpression . RBRACKET _allocexpression_line

    RBRACKET        shift and go to state 198


state 184

    (77) numexpression_line -> PLUS term numexpression_line .

    LESS_THAN       reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    GREATER_THAN    reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    LESS_EQUAL_THAN reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    GREATER_EQUAL_THAN reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    EQUAL_TO        reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    NOT_EQUAL_TO    reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    RBRACKET        reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    RPAREN          reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)
    SEMICOLON       reduce using rule 77 (numexpression_line -> PLUS term numexpression_line .)


state 185

    (78) numexpression_line -> MINUS term numexpression_line .

    LESS_THAN       reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    GREATER_THAN    reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    LESS_EQUAL_THAN reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    GREATER_EQUAL_THAN reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    EQUAL_TO        reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    NOT_EQUAL_TO    reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    RBRACKET        reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    RPAREN          reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)
    SEMICOLON       reduce using rule 78 (numexpression_line -> MINUS term numexpression_line .)


state 186

    (50) ifstat -> IF LPAREN expression RPAREN statement _ifstat .

    $end            reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    LBRACES         reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    BREAK           reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    SEMICOLON       reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    INT             reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    FLOAT           reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    STRING          reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    PRINT           reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    READ            reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    RETURN          reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    IF              reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    FOR             reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    IDENT           reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    RBRACES         reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)
    ELSE            reduce using rule 50 (ifstat -> IF LPAREN expression RPAREN statement _ifstat .)


state 187

    (51) _ifstat -> ELSE . statement
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (94) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    IDENT           shift and go to state 17

    statement                      shift and go to state 199
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    lvalue                         shift and go to state 20

state 188

    (52) _ifstat -> empty .

    ELSE            reduce using rule 52 (_ifstat -> empty .)
    $end            reduce using rule 52 (_ifstat -> empty .)
    LBRACES         reduce using rule 52 (_ifstat -> empty .)
    BREAK           reduce using rule 52 (_ifstat -> empty .)
    SEMICOLON       reduce using rule 52 (_ifstat -> empty .)
    INT             reduce using rule 52 (_ifstat -> empty .)
    FLOAT           reduce using rule 52 (_ifstat -> empty .)
    STRING          reduce using rule 52 (_ifstat -> empty .)
    PRINT           reduce using rule 52 (_ifstat -> empty .)
    READ            reduce using rule 52 (_ifstat -> empty .)
    RETURN          reduce using rule 52 (_ifstat -> empty .)
    IF              reduce using rule 52 (_ifstat -> empty .)
    FOR             reduce using rule 52 (_ifstat -> empty .)
    IDENT           reduce using rule 52 (_ifstat -> empty .)
    RBRACES         reduce using rule 52 (_ifstat -> empty .)


state 189

    (53) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON . atribstat RPAREN statement
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (94) lvalue -> . IDENT lvalue_line

    IDENT           shift and go to state 17

    atribstat                      shift and go to state 200
    lvalue                         shift and go to state 20

state 190

    (7) funcdef -> DEFINE IDENT LPAREN paramlist RPAREN LBRACES . statelist RBRACES
    (54) statelist -> . statement _statelist
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (94) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    IDENT           shift and go to state 17

    statelist                      shift and go to state 201
    statement                      shift and go to state 33
    vardecl                        shift and go to state 5
    atribstat                      shift and go to state 7
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    lvalue                         shift and go to state 20

state 191

    (8) paramlist -> INT IDENT _paramlist .

    RPAREN          reduce using rule 8 (paramlist -> INT IDENT _paramlist .)


state 192

    (12) _paramlist -> COMMA . paramlist
    (8) paramlist -> . INT IDENT _paramlist
    (9) paramlist -> . FLOAT IDENT _paramlist
    (10) paramlist -> . STRING IDENT _paramlist
    (11) paramlist -> . empty
    (97) empty -> .

    INT             shift and go to state 144
    FLOAT           shift and go to state 145
    STRING          shift and go to state 146
    RPAREN          reduce using rule 97 (empty -> .)

    paramlist                      shift and go to state 202
    empty                          shift and go to state 147

state 193

    (13) _paramlist -> empty .

    RPAREN          reduce using rule 13 (_paramlist -> empty .)


state 194

    (9) paramlist -> FLOAT IDENT _paramlist .

    RPAREN          reduce using rule 9 (paramlist -> FLOAT IDENT _paramlist .)


state 195

    (10) paramlist -> STRING IDENT _paramlist .

    RPAREN          reduce using rule 10 (paramlist -> STRING IDENT _paramlist .)


state 196

    (45) _paramlistcall -> COMMA paramlistcall .

    RPAREN          reduce using rule 45 (_paramlistcall -> COMMA paramlistcall .)


state 197

    (35) _atribstat -> LPAREN numexpression RPAREN term_line _expression .

    SEMICOLON       reduce using rule 35 (_atribstat -> LPAREN numexpression RPAREN term_line _expression .)
    RPAREN          reduce using rule 35 (_atribstat -> LPAREN numexpression RPAREN term_line _expression .)


state 198

    (61) allocexpression_line -> LBRACKET numexpression RBRACKET . _allocexpression_line
    (62) _allocexpression_line -> . allocexpression_line
    (63) _allocexpression_line -> . empty
    (61) allocexpression_line -> . LBRACKET numexpression RBRACKET _allocexpression_line
    (97) empty -> .

    LBRACKET        shift and go to state 162
    SEMICOLON       reduce using rule 97 (empty -> .)
    RPAREN          reduce using rule 97 (empty -> .)

    _allocexpression_line          shift and go to state 203
    allocexpression_line           shift and go to state 204
    empty                          shift and go to state 205

state 199

    (51) _ifstat -> ELSE statement .

    ELSE            reduce using rule 51 (_ifstat -> ELSE statement .)
    $end            reduce using rule 51 (_ifstat -> ELSE statement .)
    LBRACES         reduce using rule 51 (_ifstat -> ELSE statement .)
    BREAK           reduce using rule 51 (_ifstat -> ELSE statement .)
    SEMICOLON       reduce using rule 51 (_ifstat -> ELSE statement .)
    INT             reduce using rule 51 (_ifstat -> ELSE statement .)
    FLOAT           reduce using rule 51 (_ifstat -> ELSE statement .)
    STRING          reduce using rule 51 (_ifstat -> ELSE statement .)
    PRINT           reduce using rule 51 (_ifstat -> ELSE statement .)
    READ            reduce using rule 51 (_ifstat -> ELSE statement .)
    RETURN          reduce using rule 51 (_ifstat -> ELSE statement .)
    IF              reduce using rule 51 (_ifstat -> ELSE statement .)
    FOR             reduce using rule 51 (_ifstat -> ELSE statement .)
    IDENT           reduce using rule 51 (_ifstat -> ELSE statement .)
    RBRACES         reduce using rule 51 (_ifstat -> ELSE statement .)


state 200

    (53) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat . RPAREN statement

    RPAREN          shift and go to state 206


state 201

    (7) funcdef -> DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist . RBRACES

    RBRACES         shift and go to state 207


state 202

    (12) _paramlist -> COMMA paramlist .

    RPAREN          reduce using rule 12 (_paramlist -> COMMA paramlist .)


state 203

    (61) allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line .

    SEMICOLON       reduce using rule 61 (allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line .)
    RPAREN          reduce using rule 61 (allocexpression_line -> LBRACKET numexpression RBRACKET _allocexpression_line .)


state 204

    (62) _allocexpression_line -> allocexpression_line .

    SEMICOLON       reduce using rule 62 (_allocexpression_line -> allocexpression_line .)
    RPAREN          reduce using rule 62 (_allocexpression_line -> allocexpression_line .)


state 205

    (63) _allocexpression_line -> empty .

    SEMICOLON       reduce using rule 63 (_allocexpression_line -> empty .)
    RPAREN          reduce using rule 63 (_allocexpression_line -> empty .)


state 206

    (53) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN . statement
    (14) statement -> . vardecl SEMICOLON
    (15) statement -> . atribstat SEMICOLON
    (16) statement -> . printstat SEMICOLON
    (17) statement -> . readstat SEMICOLON
    (18) statement -> . returnstat SEMICOLON
    (19) statement -> . ifstat
    (20) statement -> . forstat
    (21) statement -> . LBRACES statelist RBRACES
    (22) statement -> . BREAK SEMICOLON
    (23) statement -> . SEMICOLON
    (24) vardecl -> . INT IDENT vardecl_line
    (25) vardecl -> . FLOAT IDENT vardecl_line
    (26) vardecl -> . STRING IDENT vardecl_line
    (29) atribstat -> . lvalue ASSIGN _atribstat
    (47) printstat -> . PRINT expression
    (48) readstat -> . READ lvalue
    (49) returnstat -> . RETURN
    (50) ifstat -> . IF LPAREN expression RPAREN statement _ifstat
    (53) forstat -> . FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement
    (94) lvalue -> . IDENT lvalue_line

    LBRACES         shift and go to state 13
    BREAK           shift and go to state 14
    SEMICOLON       shift and go to state 6
    INT             shift and go to state 16
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    PRINT           shift and go to state 21
    READ            shift and go to state 22
    RETURN          shift and go to state 23
    IF              shift and go to state 24
    FOR             shift and go to state 25
    IDENT           shift and go to state 17

    atribstat                      shift and go to state 7
    statement                      shift and go to state 208
    vardecl                        shift and go to state 5
    printstat                      shift and go to state 8
    readstat                       shift and go to state 9
    returnstat                     shift and go to state 10
    ifstat                         shift and go to state 11
    forstat                        shift and go to state 12
    lvalue                         shift and go to state 20

state 207

    (7) funcdef -> DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES .

    DEFINE          reduce using rule 7 (funcdef -> DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES .)
    $end            reduce using rule 7 (funcdef -> DEFINE IDENT LPAREN paramlist RPAREN LBRACES statelist RBRACES .)


state 208

    (53) forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .

    $end            reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    LBRACES         reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    BREAK           reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    SEMICOLON       reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    INT             reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    FLOAT           reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    STRING          reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    PRINT           reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    READ            reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    RETURN          reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    IF              reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    FOR             reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    IDENT           reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    RBRACES         reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)
    ELSE            reduce using rule 53 (forstat -> FOR LPAREN atribstat SEMICOLON expression SEMICOLON atribstat RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for TIMES in state 97 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 97 resolved as shift
WARNING: shift/reduce conflict for MODULO in state 97 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 170 resolved as shift
WARNING: reduce/reduce conflict in state 97 resolved using rule (unaryexpre -> factor)
WARNING: rejected rule (empty -> <empty>) in state 97
